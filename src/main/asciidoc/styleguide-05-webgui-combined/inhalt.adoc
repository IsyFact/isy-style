[[anforderungen]]
= Anforderungen

[[allgemeine-anforderungen]]
== Allgemeine Anforderungen

Die in diesem Dokument aufgestellten Vorgaben setzen folgende Anforderungen um:

*Einfachheit der Verwendung von JSF*: Hier werden die Konfiguration und der Einsatz der verwendeten Technologien festgelegt.
Dazu zählen:

** Einsatz von Facelets
** Einsatz von Tag Libraries
** Fehlerbehandlung
** Anbindung von Hilfesystemen

*Einfachheit des Einsatzes von Spring Web Flow:* Die Definition der Dialogschritte und die Abhängigkeiten zu den zugehörigen Daten für die Darstellung wird über Spring Web Flow festgelegt.
Hierzu werden folgende Themenbereiche genauer definiert:

** Konfiguration der Dialog Abläufe (Flow)
** Anbindung der Backend Services (Spring Beans)

*Einfachheit des Session Management:* Hier wird definiert, wie die Behandlung von Session Informationen erfolgen soll und welche wiederverwendbaren Services zur Verfügung gestellt werden.

[[sicherheitsanforderungen]]
== Sicherheitsanforderungen

Web-Anwendungen sind besonderen Gefährdungen ausgesetzt.
Folgende Anforderungen müssen bei der Entwicklung von Web-Anwendungen berücksichtigt werden:

* Entwickler müssen sich mit den TOP10 Risiken für Web-Anwendungen gemäß OWASP vertraut machen (siehe <<OWASP10>>)
* Vertrauliche Informationen dürfen nicht als GET-Parameter übermittelt werden.
Dies verhindert, dass solche Informationen ungewollt in Log-Dateien, Caches usw.
gespeichert werden.

[[verwendete-basistechnologien]]
= Verwendete Basistechnologien

Die Übersicht der Basistechnologien soll dem Leser einen einfacheren Einstieg in die angewendeten Frameworks und Technologien ermöglichen, zusätzlich findet sich noch ein Verweis auf die konkret eingesetzten Implementierungen.
Hierbei werden auch Architekturprinzipien angesprochen, welche in den Technologien Verwendung finden.

Für detaillierte Informationen über die verwendeten Technologien sei auf entsprechende Literatur verwiesen:
<<WikiJSF>>, <<SWF>> und <<Spring>>.

[[jsf-facelets]]
== JSF / Facelets

Nachfolgend soll kurz eine Erläuterung der Begrifflichkeiten vorgenommen werden:

* Java Server Faces (JSF) ist ein Framework für die Entwicklung von Webanwendungen.
Es implementiert wie auch weitere Java-Frameworks die MVC-Architektur.
Der Schwerpunkt von JSF ist die Bereitstellung grafischer Komponenten wie z.B. Tabellen, Formulare, Kalender,
Menüs, Editoren, usw.
für die Entwicklung von Webanwendungen.
Zentrales Konzept hinter JSF ist die Bereitstellung eines Komponentenbaumes.
Aus diesem Baum wird zum Schluss der Bearbeitung die HTML Seite generiert.
+
Für JSF kommt die SUN Referenzimplementierung zum Einsatz und wird im Bereich der Komponenten um die Apache
Tomahawk Bibliothek erweitert <<SUNRI>>, <<Tomahawk>>.
* Facelets sind eine alternative View Technologie für JSF, hiermit sind kleine, wieder verwendbare
GUI-Komponenten möglich, die durch ein entsprechendes XML-Tag in eine Seite inkludiert werden.
Im Gegensatz zu Taglibs erfolgt ein Include der Komponente und kein Aufruf von Java-Code für die
Generierung von gerendertem GUI-Code.
Hierbei wird der Templating Mechanismus der Facelets verwendet.
Facelets bieten vielfältige Möglichkeiten Vorlagenfragmente zu einer Gesamtseite zusammenzusetzen - zum
Beispiel um auf jeder Seite eine einheitliche Kopfzeile zu realisieren.
+
Weiter können Facelets mit herkömmlichen HTML-Editoren bearbeitet werden und sind somit einfacher zu
verstehen und zu editieren.
Die Ablage erfolgt hierbei dann in XHTML-Dokumenten.
Als Implementierung kommt die SUN Bibliothek für Facelets <<Facelets>> zum Einsatz.
* Model-View-Controller (MVC, „Modell / Präsentation / Steuerung“) bezeichnet ein Architekturmuster zur
Strukturierung von Software-Entwicklung in die drei Einheiten _Datenmodell_ (engl.
_Model_), _Präsentation_ (engl.
_View_) und _Programmsteuerung_ (engl.
_Controller_). Ziel des Musters ist es, einen flexiblen Programmentwurf zu machen, der u. A. eine spätere
Änderung oder Erweiterung erleichtert und eine Wiederverwendung der einzelnen Komponenten ermöglicht.
Dieses Muster ist in <<image-MVCPat>> dargestellt.

:desc-image-MVCPat: MVC Pattern
[id="image-MVCPat",reftext="{figure-caption} {counter:figures}"]
.{desc-image-MVCPat}
image::MVC.png[align="center"]

[[bearbeitungsmodell-einer-jsf-anfrage]]
=== Bearbeitungsmodell einer JSF Anfrage

Die Spezifikation der Java Server Faces definiert einen sogenannten Lebenszyklus <<WikiJSF>> , den eine
JSF-Anwendung mit jedem Aufruf erneut durchläuft.
Dieser Lebenszyklus ist in sechs _Phasen_ (englisch _Phases_) aufgeteilt.

[frame="none",cols="2,1"]
|====
a|
1.  _Restore View_ („Sicht wiederherstellen“) wählt anhand der eingehenden Anforderung eine Sicht (_View_) aus und baut den dazu passenden Komponentenbaum bei Bedarf auf.
2.  _Apply Request Values_ („Anforderungsparameter anwenden“) extrahiert Parameter aus der Anforderung (üblicherweise ein HTTP-Post-Request) und weist sie den passenden JSF-Komponenten zu, beispielsweise Eingabefeldern.
3.  _Process Validations_ („Validierung ausführen“) überprüft die Gültigkeit der zuvor ermittelten Eingaben.
Dazu werden eigene Validator-Objekte verwendet, die den Komponenten in der View-Definition zugewiesen wurden.
4.  _Update Model Values_ („Modell aktualisieren“) weist den Modellobjekten die zuvor ermittelten Werte zu.
5.  _Invoke Application_ („Anwendung aufrufen“) ruft durch die Anwendung definierte Methoden auf, beispielsweise wenn ein Button betätigt wurde.
6.  _Render Response_ („Antwort wiedergeben“) erzeugt schließlich die Antwort auf die ursprüngliche Anfrage, beispielsweise eine HTML-Seite.
Hierzu werden sogenannte _Renderer_ aufgerufen, die den View-Komponenten zugeordnet sind.

a|
:desc-image-PhasemodJSF: Phasenmodell JSF
[id="image-PhasemodJSF",reftext="{figure-caption} {counter:figures}"]
.{desc-image-PhasemodJSF}
image::PhasemodJSF.png[align="center"]
|====

Treten Fehler auf, oder soll als Antwort beispielsweise eine HTML-Seite aufgerufen werden, die keine
JSF-Komponenten enthält, so können einzelne Phasen übersprungen werden.

[[datenmodell]]
=== Datenmodell

Die Daten für die Visualisierung in JSF werden in Model Beans gehalten.
Hierfür wird nicht auf den durch JSF zur Verfügung gestellten Mechanismus der Managed Beans zurückgegriffen.
Das Datenmodell wird über Spring Web Flow direkt aus Model Beans verfügbar gemacht.
Damit ist die Verwaltung des Models unter Kontrolle des Dialogflusses welcher über Spring Web Flow gesteuert wird.
Die einem Flow zugeordneten Model Beans werden durch den Flow instanziiert und unterliegen somit dem Flow-Lebenszyklus.

[[facelets]]
=== Facelets

Mit den Facelets werden das visuelle Layout und die Controls für die Ansicht im Browser definiert.
Durch die Nähe zu HTML sind schnell die notwendigen Ansichten designed und können getestet werden.
Das Mapping der Controls auf die Daten geschieht über die in JSF verwendete Expression Language (EL).
Mit der EL werden direkt die Attribute des zugehörigen Beans genutzt.

Ein weiterer Vorteil von Facelets ist die Verwendung von Templates.
Durch diese ist es möglich, bereits einen zum Styleguide <<Styleguide>> konformen Rahmen zur Verfügung zu stellen, in welchen die
Applikation lediglich durch definierte Einfügungen ihre Inhalte einbetten.

[[taglibs]]
=== Taglibs

Durch den Einsatz von Facelets ist die direkte Einbettung von Tag Libraries nicht möglich.
Vielmehr müssen diese noch separat mit einer Deskription versehen werden, aus welcher die einzelnen Tags
ersichtlich sind und ihr Mapping auf die zugehörigen Klassen definiert ist.

Für den Einsatz der myFaces Tomahawk Library wird eine entsprechende Konfiguration zur Verfügung gestellt.
Der Einsatz dieser Library unterliegt für den Einsatz in der IsyFact der allgemeinen Einschränkung bei der Verwendung von JavaScript.
Siehe auch Kapitel <<praemissen>>.

[[spring-web-flow]]
== Spring Web Flow

Spring Web Flow ist ein Framework für die Ablaufsteuerung von Anwendungsfällen innerhalb von Web-Anwendungen.
Ein solcher „Flow“ innerhalb von Spring Web Flow ist eine Abfolge zusammenhängender Masken, wie z.B. das Durchlaufen der Schritte zur Registrierung eines neuen Benutzers in einer Web Anwendung.

Ein erklärtes Ziel von Spring Web Flow ist die Unterstützung der Browser-Navigation, die in der Web-Entwicklung immer wieder zu Problemen führt.
Das Framework übernimmt dabei die Navigation zwischen den einzelnen Views und stellt darüber hinaus einen eigenen Scope Container für Model Beans zur Verfügung.
Dieser erweitert die Web-Anwendung um die folgenden Scopes:

* Flash: Gültig, solange der Flow aktiv ist, jedoch werden Flash Scope Beans nach jedem View-State geleert und dienen somit dazu, Daten zwischen zwei User Events zu transferieren.
* Flow: Steht über die gesamte Laufzeit des Flows zur Verfügung.
* Conversation: Die Lebensdauer ist mit dem Flow Scope identisch, nur stehen Conversation Scope Beans auch in den zugehörigen Subflows zur Verfügung.

Spring Web Flow implementiert im Kern einen finiten Zustandsautomaten, der auf definierte Anfangs- und Endzustände angewiesen ist.

Der Ablauf der logisch zusammenhängenden Views wird in einem so genannten Flow definiert.
Innerhalb eines Flows stehen verschiedene States zur Verfügung.
Zunächst muss jeder Flow einen Start State und einen End State besitzen.
Der Start State definiert den Einstiegspunkt und aktiviert den jeweiligen Flow.
Dieser bleibt so lange aktiv, bis ein End State erreicht wird.

Wie bereits erwähnt, setzt sich Spring Web Flow das Ziel, die Browser-Navigation mit „Back-/Forward-Button“ zu unterstützen.
Um diese Funktionalität zu gewährleisten, muss die Möglichkeit bestehen, den Zustand einer View zu speichern und wieder abzurufen.
Hierfür steht ein so genanntes Repository zur Verfügung, welches die Zustände der einzelnen Views innerhalb eines Flows zwischenspeichert.
Dadurch kann man den Zustand jeder View innerhalb eines Flows zu einem beliebigen Zeitpunkt reproduzieren.

[[flows-subflows]]
=== Flows / Subflows

Ein Flow kann wahlweise als XML-Datei oder mittels der Java-API realisiert werden.
Ein Flow besteht in der Regel aus mehreren Zuständen (innerhalb von Web Flow als States bezeichnet), die nacheinander und in Abhängigkeit von der jeweiligen Benutzerinteraktion durchlaufen werden.

Auch die Modularisierung von Flows in kleine Einheiten ist durch so genannte Subflows bzw.
Inline-Flows ohne weiteres möglich.
Ein Subflow wird wie jede andere Flow-Definition erstellt.
Der Unterschied zu einem normalen Flow liegt lediglich darin, dass der Subflow innerhalb eines Flows aufgerufen wird.
Eine Flow-Definition kann beliebig viele Subflows enthalten, welche wiederum weitere Subflows aufrufen können.

[[back-button-handling]]
=== Back-Button Handling

Während der Ausführung von Flows werden die Variablen mit einer Zwischenspeicherung in das Repository geschrieben.
Hierbei wird immer, wenn ein Flow durch eine User-Interaktion unterbrochen wird, der aktuelle Status gespeichert.
Das Repository liefert diesen bei der Fortsetzung des Flows zurück.
Der dafür notwendige „Flow-Execution-Key“, der Schlüssel, der zur Identifikation des aktuellen Flow-Status dient,
wird hierbei von Spring Web Flow erzeugt.

Dieses Speichern des Status von vorhergehenden Schritten im Flow unterstützt so in Kombination mit
einem „Post Redirect Get“ Mechanismus (PRG-Pattern) die Nutzung des Back-Buttons im Browser.
Da jeder Request im Flow einen eindeutigen Execution Key an den Server sendet, kann, wenn man im
Flow zurückgeht, auch der alte Status zum Zeitpunkt dieses Request angezeigt werden, selbst wenn der Server von dem Click auf den Back-Button selbst nichts mitbekommt.

[[spring-dependency-injection]]
== Spring Dependency Injection

Das Spring Framework ist ein Java EE Framework.
In ihm werden die Bestandteile eines Systems als „Beans“ definiert.
Neben seiner Kern-Funktionalität, der Verwaltung, Konfiguration und aspektorientierten Erweiterung von Beans, bietet Spring viele Funktionalitäten, welche die Entwicklung einer Anwendung erleichtern.

Für das Web-GUI findet primär der Basisteil von Spring Verwendung, in welchem der Anwendung über Dependency Injection Beans zur Verfügung gestellt werden <<Spring>>.

[[transaktionsbehandlung]]
== Transaktionsbehandlung

Die GUI-Komponente und der Anwendungskern (AWK) sind Teil derselben Web-Applikation und werden per Spring-Konfiguration miteinander verbunden.

Oft gibt es den Fall, dass über die GUI eine Aktion in einer anderen Anwendung ausgelöst werden soll.
Ein Beispiel dafür ist die GUI einer Fachanwendung zur Datenerfassung, wobei die Speicherung der Daten über einen Service einer anderen Fachanwendung implementiert ist.
In diesem Fall enthält der Anwendungskern der Fachanwendung zur Datenerfassung nur wenig Funktionalität: in ihm werden die Daten für den Serviceaufruf der nachgelagerten Fachanwendung aufbereitet und der Serviceaufruf selbst durchgeführt.
Wichtig in diesem Fall ist, dass es nach Zielarchitektur keine Transaktionen über Serviceaufrufe hinweg gibt.

In diesem Abschnitt wird die Behandlung von Transaktionen innerhalb einer Anwendung beschrieben.
Grundregel dabei ist, dass die Komponente GUI die Transaktion steuert.
Dabei muss die Komponente GUI die Brücke schlagen zwischen der _fachlichen Transaktion_, die dem Nutzer dargestellt wird und der _technischen Transaktion,_ die in der Datenbank abgebildet wird.

Die fachliche Transaktion entspricht einem Dialogablauf.
Ein Beispiel dafür: Der Nutzer kann in der Regel über mehrere Masken hinweg Daten eingeben.
Abschließend drückt er in ein Dialog den „OK“- bzw.
den „Abbrechen“-Button.
Für den Nutzer ist klar, dass alle die von ihm eingegebenen Daten im Sinne einer Transaktion behandelt werden müssen, d. h. sie werden entweder vom System komplett übernommen oder komplett verworfen.

Aus technischer Sicht ist die Behandlung dieses Ablaufs etwas komplizierter: Die Daten, die der Nutzer in den verschiedenen Dialogen eingibt, müssen zunächst zwischengespeichert werden, bevor dann bei Betätigung eines Buttons die technische Transaktion in der Datenbank erfolgt.
Das Zwischenspeichern der Werte benötigt allerdings ebenfalls technische Transaktionen.
Da der Prozess der Web-Anwendung zustandslos ist, muss das Zwischenspeichern ebenfalls in der Datenbank erfolgen.
Hier muss die GUI zusätzliche Transaktionen durchführen.

Bei der Spring Web Flow Integration wurde ein Mechanismus verwendet, um die Zwischenwerte und Informationen zum Dialogablauf in der Datenbank abzulegen.
Das Zwischenspeichern erfolgt grundsätzlich in einer separaten Transaktion.
Somit beeinflussen sich die fachliche Transaktion und die technischen Transaktionen nicht.

Mit den technischen Transaktionen ist es jetzt möglich, „Sitzungen“ abzubilden.
Eine Sitzung ist letztendlich die Summe aller Zwischendaten, die der Nutzer eingegeben hat oder die das System selbst erzeugt hat, wie z. B. interne Zustände, Nutzerinformationen, etc.
Innerhalb einer Sitzung werden mehrere fachliche Transaktionen durchgeführt.

Das technische Mittel zur Repräsentation einer Sitzung ist zunächst einmal die Session des Servers.
Diese Session ist transient.
Da der Serverprozess zustandslos ist, muss sie in der Datenbank persistiert werden.
Dazu gibt es zwei Alternativen:

* Serialisierung der Session nach Beendigung des Request und Wiederherstellung bei neuerlichem Aufruf
* Speichern des Spring Web Flow State an den durch Spring Web Flow vorgesehenen Hooks

Die Variante der Session Serialisierung ist zwar einfacher, beinhaltet aber auch eine wesentliche Gefahr.
Die Session des Servers wird zum Speichern von verschiedensten Daten genutzt, der Zugriff auf sie ist frei möglich.
Dies führt in der Praxis dazu, dass unkontrolliert große Datenmengen in der Session abgelegt werden.
Diese großen Datenmengen lassen sich dann nicht mehr effizient persistieren.
Daher wurde diese Option in <<IsyFact-Referenzarchitektur>> ausgeschlossen.
Die Details dazu, wie in Spring Web Flow die zu speichernden Daten einer Session ermittelt werden, finden sich
in Kapitel <<session-behandlung>>.

[[jquery]]
== JQuery

JQuery ist ein JavaScript-Framework, das auf einfache Weise JavaScript-Funktionen bereitstellt,
die insbesondere auf die grafische Gestaltung einer Oberfläche benötigt werden.
Die JavaScript-Datei, die diese Funktionen enthält wird im folgenden JQuery-Bibliothek genannt.

Die Homepage jquery.com bietet die Möglichkeit Module individuell zusammenzustellen, so dass nur die
benötigten Funktionen zur Verfügung stehen.
Für die IsyFact wurde eine Auswahl der nutzbaren Module zusammengestellt.

Erklärtes Ziel ist es, die Oberfläche durch den Einsatz von JavaScript eleganter nutzbar zu machen.
Besonderer Fokus liegt dabei auf den Sicherheitsaspekten, die eine Aktivierung von JavaScript mit sich bringt.
Die Oberfläche muss jedoch auch mit deaktiviertem JavaScript mit Komforteinschränkungen nutzbar sein.

JQuery ist modular aufgebaut. Folgende Module dürfen eingesetzt werden:

NOTE: Fertige jQuery-Pakete inkl. Stylesheet sollten in <<IsyFactJQuery>> abgelegt sein. Sie werden jedoch nicht als
Teil der IsyFact ausgeliefert.

* jquery-core (Kernfunktionalität zur DOM-Manipulation)
* jquery-effects (Ein- und Ausblendfunktionalität)
* jqueryui-datepicker (Kalender-Widget)
* jquery-validation-plugin (Datenvalidierung)

Die Module jquery-data und jquery-ajax werden explizit nicht gesetzt, da AJAX-Funktionalität im Hinblick auf die eingesetzte Seitenlogik mit Spring-Web Flow nicht angeboten werden soll.

[[bootstrap]]
== Bootstrap

Bootstrap ist ein Open-Source CSS Framework, welches im Web sehr weit verbreitet ist.
Es bietet z.B. Funktionalitäten für das Layouting, Scaffolding und kann dynamisch auf die vorgegebene
Fenstergröße reagieren (Responsive CSS).

Über eine ergänzende JavaScript Bibliothek (welche selbst wiederum JQuery nutzt), stellt das Framework
auch Komponenten wie Navigations-Menüs und Dropdowns zur Verfügung.

[[architektur]]
= Architektur

Im Folgenden soll eine grobe Übersicht über die Zusammenhänge der Web-GUI-Architektur und deren Einbettung
in die Referenzarchitektur der IsyFact gegeben sowie die grundlegende Architektur der GUI-Komponenten erläutert werden.

[[referenzarchitektur-einer-fachanwendung]]
== Referenzarchitektur einer Fachanwendung

Das Nutzungskonzept für das Web-GUI nimmt Bezug auf die in der Referenzarchitektur vorgegebenen Schichten
und Komponenten einer IsyFact-konformen Fachanwendung.

:desc-image-RAFachAnw: Referenzarchitektur einer Fachanwendung
[id="image-RAFachAnw",reftext="{figure-caption} {counter:figures}"]
.{desc-image-RAFachAnw}
image::IFRefArcITSysGUI.png[align="center"]

Die Schicht der Nutzung ist eine Erweiterung der klassischen 3-Schichten Architektur, in der die oberste
Schicht in GUI, Batch und Service differenziert wird.

Das vorliegende Dokument beschreibt die Ausgestaltung der Komponente „GUI“. Aufgabe der GUI ist es, die
Funktionalität der Anwendung für einen menschlichen Nutzer zur Verfügung zu stellen.
Dazu stellt sie die benötigten Dialoge und Masken bereit.

Die GUI ist untergliedert in ein GUI-Framework (verwendet wird JSF mit Spring Web Flow) und die Dialoglogik,
welche die für den Anwendungsfall notwendigen Anforderungen umsetzt <<IsyFact-Referenzarchitektur>>.

[[grundprinzipien-der-web-gui]]
== Grundprinzipien der Web-GUI

Die Architektur der GUI ist durch die Eigenschaften der eingesetzten Frameworks JSF und Spring Web Flow weitgehend vorgegeben.
Darin sind diese grundlegenden Prinzipien enthalten:

* Nutzung des MVC-Patterns
* Trennung des Dialogs in Dialogsteuerung und Präsentation
* Dialogsteuerung über das Spring Web Flow Framework
* Bildung von gekapselten GUI-Komponenten
* Präsentation über JSF und Facelets
* Verwaltung von Nutzer Sessions über Spring Web Flow
* Interaktive Oberflächenelemente mit JQuery und JQueryUI

[[integration-mit-dem-framework-spring-web-flow]]
== Integration mit dem Framework Spring Web Flow

<<image-IntvSpringSWF>> zeigt die Komponenten für die Web-GUI und die Integration mit dem Framework Spring Web Flow.

:desc-image-IntvSpringSWF: Integration von Spring bzw. Spring-Web-Flow
[id="image-IntvSpringSWF",reftext="{figure-caption} {counter:figures}"]
.{desc-image-IntvSpringSWF}
image::IntvSpringSWF.png[align="center"]

Durch den Programmierer einer GUI sind die gelb hervorgehobenen Teile bereitzustellen (die anderen Bestandteile
werden durch das Framework bereitgestellt).

* Konfiguration des Dialogablaufs als Flow in Form von XML-Dateien
* Model und Controller-Beans zur Datenhaltung und für GUI-Logik
* Visualisierung durch Facelets in XHTML-Dateien

[[gui-komponenten]]
== GUI-Komponenten

Zur Strukturierung von Masken und zugehöriger Funktionalität verwenden wir ein einheitliches Muster zum Aufbau
von GUI-Komponenten.
Neben der Anwendung des MVC-Pattern mittels der oben beschriebenen Web-Technologien (Spring Web Flow, JSF)
definiert es zusätzlich Regeln, die eine Kapselung -, einen einheitlichen Aufbau und eine einheitliche Interaktion
von GUI-Komponenten ermöglicht.

Die Fachkomponenten einer Anwendung ergeben sich aus der Systemspezifikation.
Diese werden auf der Ebene Persistenz, Anwendungskern und GUI implementiert (siehe <<image-RAFachAnw>>). Auf Ebene der
GUI sprechen wir von GUI-Komponenten (siehe <<image-KompDiazuGUI>>).

Die GUI-Komponenten umfassen für jeden Dialog eine Subkomponente.
Jeder Dialog aus der Systemspezifikation ist also ebenfalls eine eigene Komponente.

:desc-image-KompDiazuGUI: Komposition von Dialogen zu GUI-Komponenten
[id="image-KompDiazuGUI",reftext="{figure-caption} {counter:figures}"]
.{desc-image-KompDiazuGUI}
image::KompDiazuGUI.png[align="center",pdfwidth=80%,width=80%]

Die Dialog-Komponenten einer GUI-Komponente können einen gemeinsamen AWK-Wrapper und in ihren Modellen
gemeinsame Datenobjekte verwenden.
Trotzdem sind die Dialog-Komponenten zu kapseln, d.h. Controller- und Model Beans dürfen nicht gemeinsam
verwendet werden (siehe <<image-IntGUIKompGUISub>>).

:desc-image-IntGUIKompGUISub: Innensicht einer GUI-Komponente mit ihren GUI-Sub-Komponenten
[id="image-IntGUIKompGUISub",reftext="{figure-caption} {counter:figures}"]
.{desc-image-IntGUIKompGUISub}
image::IntGUIKompGUISub.png[align="center"]

Zentral ist also die Forderung, dass die Elemente jeder GUI-Komponente (Flow, Controller, View und Model)
in definierter Weise ausschließlich untereinander kommunizieren und Zugriffe auf Elemente anderer
Komponenten unterbleiben.
<<image-CommMVCinGUI>> zeigt die Abhängigkeits­beziehungen innerhalb einer GUI-(Sub-)Komponente.

:desc-image-CommMVCinGUI: Kommunikation von View, Controller und Model innerhalb einer GUI-Komponente
[id="image-CommMVCinGUI",reftext="{figure-caption} {counter:figures}"]
.{desc-image-CommMVCinGUI}
image::CommMVCinGUI.png[align="center"]

[[flow-als-zentraler-controller]]
=== Flow als zentraler Controller

Jede GUI-Komponente wird durch einen Flow beschrieben.
Dieser definiert das Zustandsmodell der Komponente und hat die Funktion des zentralen Controllers für diese Komponente.
Er erfüllt die folgenden Aufgaben:

* Erzeugung und Verwaltung eines (ggf. auch mehrerer) Model Beans
* Definition des Flow-Ablaufs in Form eines Zustandsautomaten mit Zuständen und Zustandsübergängen (Flow, Subflows, Decision-States, Action-States, Event-Handlers)
* Anbinden des Views
* Steuerung der Verarbeitung im Rahmen von Zustandsübergängen

Der Flow-Aufbau wird so gestaltet, dass im Flow alle Zustände, Zustandsübergänge sowie Aufrufe von Verarbeitungslogik zentral gebündelt werden und Ablauf und Verhalten des Flows für den Entwickler klar nachvollziehbar sind.

Der Flow wird als XML-Datei im Ordner der Komponente hinterlegt.

[[controller-bean]]
=== Controller-Bean

Das Controller-Bean ist ein vom Komponenten-Flow aufzurufendes *zustandsloses* Spring Bean,
welches Änderungen an den Daten des Models vornimmt oder diese aufbereitet bzw.
Services des Anwendungskern-Wrappers aufruft.
Das Model Bean wird dem Controller mit jedem Aufruf übergeben.

Architekturkonvention: Die Implementierung des Controllers ist zustandslos und stellt nur Methoden bereit.

Das Controller-Bean wird im Spring IoC-Container mit Singleton Scope erzeugt und konfiguriert.

Das Controller-Bean wird vom Flow per Expression-Language aufgerufen.
In bestimmten Fällen (siehe Abschnitt <<view544>>) wird ein Controller-Bean auch in einer Action (oder ActionListener) des
Komponenten-View aufgerufen.

[[model-bean]]
=== Model Bean

Das Model Bean ist ein Datenobjekt (einfaches POJO) und hält die Daten einer GUI-Komponente.
Es hat keine Abhängigkeiten zu View, Controller oder Anwendungskern und enthält im Regelfall keine Logik.
Das Model Bean wird durch den Flow erzeugt (durch Definition einer Web Flow-Variablen) und ist somit automatisch im View sichtbar.

:desc-listing-CreaModinFlow: Erzeugung einer Model-Instanz im Flow
[id="listing-CreaModinFlow",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-CreaModinFlow}
[source,xml]
----
<flow ...">
  <!-- Erzeuge das Model zur Benutzung durch diesen Flow. -->
  <var name="erstellenModel"
  class="de.msg.terminfindung.gui.terminfindung.erstellen.ErstellenModel" />
----

Der View liest die Daten zur Präsentation der Webseite aus dem Model Bean.
Dies können Informationen zur Ansicht aber auch änderbare Formularinhalte sein.
Werden Formularinhalte in Form eines Post-Requests auf den Server gesendet, so sorgt JSF eigenständig dafür, dass die Formularinhalte in das Model Bean rückübertragen werden.

Da das Model Bean durch den Flow erzeugt wird und Flow Scope besitzt, wird es automatisch mit in die Session-Persistierung einbezogen.
Dazu muss das Model das Interface Serializable implementieren.
Die Daten des Models werden bei den Dialogschritten eines Flow zwischen Client (Browser) und Server transparent für den Entwickler abgeglichen.

Das Model Bean ist nicht mit den JPA-Datenobjekten verbunden.
Das Schreiben in das Model bewirkt also zunächst keine Änderung in der Datenbank.
Die Persistenz fachlicher Datenobjekte wird über das Controller-Bean ausgelöst, welches über Methodenaufrufe des Anwendungskern-Wrappers fachliche Daten persistiert.

Die Verwendung von Model Beans wird im Verlauf dieses Dokuments noch genauer beschrieben.

[[view544]]
=== View

Der Komponenten-View präsentiert die Daten der Anwendung in Form von generierten HTML-Seiten.
Dazu werden ein oder mehrere Facelets verwendet, die mittels JSF-HTML-Tags auf das Model Bean der Komponente
zugreifen, um die Daten in den View einzubinden.
Da das Model Bean seine Datenzugriffsmethoden nach dem Bean-Standard (`get`/`set`/`is`) anbietet, kann mittels
 Value-Expressions (z.B. `#{teilnehmenModel.terminfindung.tage}`) direkt auf Eigenschaften des Model Beans und
 enthaltener Objekte zugegriffen werden.
Ein View kann auch auf mehrere zum Flow gehörende Model Beans zugreifen.

Im View können Actions definiert sein (z.B. Submit durch einen Command-Button). Dabei werden nur Action-Tokens
(String, der die Aktion benennt) übergeben, die dann im Flow entgegengenommen werden und dann Methodenaufrufe auf dem Controller auslösen.

Achitekturkonvention.
Aus einer Action des Views sollte i.d.R. immer ein Zustandstoken zur Steuerung von Transitionen im Flow erzeugt werden.
Dies ist vor allem bei Maskenübergängen und fachlichen Aktionen zu verwenden.
Beispiel: Suche in einem Formular, Öffnen der Detailansicht.

Aktionen, welche zur Steuerung der Darstellung innerhalb einer Maske verwendet werden, müssen nicht zwingend eine Transition auslösen.
In diesen Fällen darf der Controller direkt aufgerufen werden.
Beispiel: Selektion eines Elements und darauf basierende Anpassung der Maske.

Die Erstellung von Views wird im Verlauf dieses Dokuments noch genauer beschrieben.

[[jquery-1]]
=== JQuery

Die oben beschriebene JQuery-Bibliothek wird im Seitenrahmen eingebunden.
Sollen nun in einem View interaktive Elemente aktiviert werden, wird eine JavaScript-Datei mit dem Namen des Views benötigt und am Seitenende (Ende des Templates) eingebunden.

:desc-listing-BindViewspezJS: Einbindung View-spezifischer JS-Dateien
[id="listing-BindViewspezJS",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-BindViewspezJS}
[source,xml]
----
<script type=“text/javascript“
src="#{facesContext.externalContext.requestContextPath}/js/vorgangSuchen.js">
</script>
----

Diese Datei enthält die benötigten JavaScript-Befehle zum Erzeugen von UI-Elementen oder zum Binden von Events an bestehende Fragmente.
Von inline-JavaScript ist in jedem Fall abzusehen.

Beim Einbinden sind niemals relative Pfade zu verwenden, um die Same-Origin-Policy zu forcieren.
Zusätzlich sorgt, das script-Tag dafür, dass im Fall von deaktiviertem JavaScript kein Fehler auftritt und die
 XHTML-Konformität erhalten bleibt.

Folgende Abbildung zeigt ein Beispiel für eine Java-Script-Datei „vorgangSuchen.js“, welche ein GUI-Element mit
der ID „Geburtsdatum“ fokussiert:

:desc-listing-BspJSDat: Beispiel für eine JavaScript-Datei
[id="listing-BspJSDat",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-BspJSDat}
[source,javascript]
----
(function(){

  $('#Geburtsdatum').focus();

})()
----

[[zugriff-auf-anwendungskern]]
=== Zugriff auf Anwendungskern

In einer GUI-Komponente werden grundsätzlich keine Klassen des AWK verwendet.
Stattdessen wird vom Controller-Bean der Komponente (und nur von diesem) auf den zur GUI-Komponente gehörenden Anwendungskern-Wrapper zugegriffen, der den Anwendungskern aufruft.
In den Models der GUI-Komponenten werden eigene Datentypen und nicht die des Anwendungskerns verwendet.
Die Aufgabe des AWK-Wrappers ist die Daten vom Anwendungskern in die der GUI zu mappen.

Die Transaktionssteuerung findet im AWK-Wrapper per Annotationen an der Wrapperklasse statt.

:desc-listing-DeklTransverhaltAWKWrap: Deklaration des Transaktionsverhaltens am AWK-Wrapper
[id="listing-DeklTransverhaltAWKWrap",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-DeklTransverhaltAWKWrap}
[source,java]
----
@Transactional(rollbackFor = Throwable.class, propagation=Propagation.REQUIRED)
public class AwkWrapperImpl implements AwkWrapper {
----

Damit die Persistierung funktioniert, müssen die AWK-Wrapper-Beans im selben Spring-Applikationskontext wie der
Anwendungskern definiert werden, damit der Transaktionskontext aus der Hibernate-Konfiguration nutzbar ist.

[[schnittstellen-zwischen-komponenten]]
=== Schnittstellen zwischen Komponenten

Ein Grundprinzip der Architektur der GUI-Komponenten ist die Kapselung aller Komponenten.
Ein View oder Controller einer GUI-Komponente darf daher nicht auf das Model (oder das Controller-Bean) einer anderen GUI-Komponente zugreifen.
Der Austausch von Informationen erfolgt stattdessen über Input/Output-Elemente im Flow, die aus dem Model einer GUI-Komponente gelesen oder geschrieben werden.

Ist ein Subflow B mit Daten aus dem aufrufenden Flow A zu versorgen, so bekommt dieser nicht das Model Bean A, sondern eine Kopie eines einzelnen Objekts (kann auch eine Datenstruktur, aber niemals das gesamte Model A sein) aus A übergeben.
Es ist wichtig, dass eine Kopie übergeben wird, damit Flow B nicht Teile des Model Beans A absichtlich oder versehentlich ändert.

Besteht Bedarf, dass ein Subflow B an den aufrufenden Flow A Daten zurückgibt, so erfolgt dies über ein Output-Element.
Hier gilt analog, dass nicht das gesamte Model Bean B, sondern lediglich Einzelwerte (Kopie) übergeben werden.

Das folgende Beispiel zeigt wie ein Flow an einen Subflow Parameter übergibt und von diesem einen Ausgabewert empfängt.

:desc-listing-InfoExFaufF1: Informationsaustausch zwischen Flows – aufrufender Flow
[id="listing-InfoExFaufF1",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-InfoExFaufF1}
[source,xml]
----
<subflow-state id="loeschenViewState" subflow="loeschenFlow">
  <input name="terminfindung"
         value="verwaltenController.kopiereTerminfindungModel()"/>
  <output name="loeschenTerminfindung"/>
  <transition on="finished" to="verwaltenViewState">
    <evaluate expression="verwaltenModel.setTerminfindung(loeschenTerminfindung)"/>
  </transition>
</subflow-state>
----

Innerhalb des Subflows werden übergebene Parameter entgegengenommen und verarbeitet.
Im Endzustand wird ein Rückgabewert zurückgegeben.

:desc-listing-InfoExFaufF2: Informationsaustausch zwischen Flows – aufgerufener Flow
[id="listing-InfoExFaufF2",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-InfoExFaufF2}
[source,xml]
----
<input name="terminfindung" type="de.msg.terminfindung.gui.terminfindung.model.TerminfindungModel"/>
<on-start>
  <evaluate expression="loeschenModel.setTerminfindung(terminfindung)"/>
</on-start>
<view-state id="loeschenViewState">
  <on-entry>
    <evaluate expression="loeschenController.setzeAuswahlZurueck(loeschenModel)"/>
  </on-entry>
  <transition on="cancel" to="finished"/>
  <transition on="delete" to="loeschenViewState">
    <evaluate expression="loeschenController.loescheZeitraeume(loeschenModel)"/>
  </transition>
</view-state>

<end-state id="finished">
  <output name="loeschenTerminfindung"
          value="loeschenModel.getTerminfindung()"/>
</end-state>
----

Zur Datenübergabe können auch mehrere Input und mehrere Output-Elemente verwendet werden.

Für die Steuerung des Vorgabelayouts (z.B. Menüleiste, Linksnavigation) sowie der Nutzung von vorgegebenen Funktionen (z.B. Validierung) werden auch querschnittliche Controller mit zugehörigen Models verwendet.
Die Instanziierung übernimmt dabei ein übergeordneter Parent-Flow.
So kann z.B. die Seitentoolbar ausgeblendet oder ein Quicklink hinzugefügt werden.

Der Aufruf dieser Controller zur Steuerung des Verhaltens ist erlaubt.
Auf die Controller kann per Spring zugegriffen werden.
Welche Controller im Detail für das Vorgabelayout verfügbar sind, wird in <<Styleguide>> aufgelistet.

[[packaging-und-namenskonventionen]]
=== Packaging und Namenskonventionen

Ein nicht zu vernachlässigender Aspekt zur Komponentenbildung ist die Paketierung, durch die zu einer
Komponente gehörende Elemente gruppiert abgelegt werden.
Alle Elemente werden in einem Paket mit einheitlichem Paketnamen abgelegt.

Für die Namenskonvention zu Java-Klassen und Paketen wird hier auf das Dokument <<Java-Programmierkonventionen>> verwiesen.
Zusätzlich gelten die folgenden Konventionen:

* Jede GUI-Komponente hat einen Namen.
Die Namen richten sich nach den fachlichen Komponenten bzw. Dialogen.
* Das Paket, in dem die GUI-Komponente abgelegt wird, trägt den vollständig kleingeschriebenen Namen der
GUI-(Sub-)Komponente (z.B. `erstellen`). Jede GUI-Komponente nutzt zwei Ablageorte:
** `java/de/…/gui/terminfindung/erstellen/...` für Java-Klassen
** `WEB-INF/gui/terminfindung/erstellen/...` für Flows und Views
* Model Bean-Klassen tragen den Namen der GUI-Komponente und enden auf Model (z.B. `ErstellenModel`).
* Controller Bean-Klassen tragen den Namen der GUI-Komponente und enden auf Controller (z.B. `ErstellenController`).
* Flows tragen den Namen der GUI-Komponente und enden auf Flow.xml (z.B. `erstellenFlow.xml`).
* Der Main-View, der dem Flow-View-State zugeordnet ist endet auf `ViewState` (z.B. `erstellenViewState.xhtml`).
Besteht der Flow aus mehreren View-States, so wird eine Schritt-Nummer angehängt (z.B. `erstellenViewState1.xhtml`).
* Alle weiteren für den View verwendeten Facelets tragen den Namen der Komponente und eine Charakterisierung
des Facelets (z.B. `erstellenFormular.xhtml`). Auch hier ist eine Schrittnummer anzuhängen, wenn der Flow mehrere View-States enthält (z.B. erstellenFormular1.xhtml).
* Die bei einem View-State verwendete JavaScript-Datei trägt den Namen des View-States (z.B. `erstellenFormular1.js`).
Gibt es View-übergreifende Funktionalität kann diese in eine wiederverwendbare
JavaScript-Datei ausgelagert werden (z.B. `erstellenForumlar.js`).

Im folgenden Abschnitt ist die Benennung der Elemente auch noch einmal in Form der Projektdateistruktur
nachvollziehbar dargestellt.

[[projekt-verzeichnis-einer-fachanwendung-mit-gui]]
=== Projekt-Verzeichnis einer Fachanwendung mit GUI

Nachfolgend ist in <<image-VerzBspErstellen>> der Verzeichnisbaum der Beispiel-Implementierung (insbesondere die GUI-Komponente
`Erstellen`) dargestellt, in dem zu sehen ist, wie die Elemente der GUI im Dateisystem abgelegt werden.

:desc-image-VerzBspErstellen: Verzeichnisstruktur am Beispiel Erstellen
[id="image-VerzBspErstellen",reftext="{figure-caption} {counter:figures}"]
.{desc-image-VerzBspErstellen}
image::bspstructmit.png[align="center"]

////
Projekt Terminfindung
Java Quellcode
Java Quellcode für GUI
AwkWrapper für die CD-Verwaltung
GUI-Sub-Komponenten (Dialoge) der Terminfindung
_Erstellen_ mit Controller und Model Bean
Ressourcen (Spring / Texte)
Stylesheet
Grafiken
JavaScript
GUI-Komponenten der Anwendung
GUI-Komponente _Erstellen_
_Erstellen_ mit Flow und View
Web/Web Flow/JSF Konfiguration
////

[[umsetzen-der-web-gui-einer-isyfact-anwendung]]
= Umsetzen der Web-GUI einer IsyFact-Anwendung

[[praemissen]]
== Prämissen

Für die Erstellung von Weboberflächen existieren Vorgaben in Form eines Styleguides <<Styleguide>>. Hierüber werden Anforderungen an die Gestaltung und Nutzbarkeit von Oberflächen, sowie technische Aspekte, wie die Verwendung von Javascript oder zu unterstützende Browser festgelegt.

[[erstellung-einer-gui-komponente]]
== Erstellung einer GUI-Komponente

[[der-flow]]
=== Der Flow

Für eine GUI-Komponente wird zunächst die Definition des Flow als XML-Datei erstellt.
Spring Web Flow sucht und findet den Flow selbständig und nimmt ihn in die Flow-Registry auf.
Zunächst ein exemplarisches Beispiel:

:desc-listing-fullFlowBSPTeilnehmen: Ein vollständiger Flow am Beispiel teilnehmenFlow.xml
[id="listing-fullFlowBSPTeilnehmen",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-fullFlowBSPTeilnehmen}
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<flow xmlns="http://www.springframework.org/schema/webflow"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.springframework.org/schema/webflow
                          http://www.springframework.org/schema/webflow/spring-webflow-2.4.xsd"
      parent="basisFlow">
   <var name="teilnehmenModel"
        class="de.msg.terminfindung.gui.terminfindung.teilnehmen.TeilnehmenModel" />
   <var name="tfRef" class="java.lang.String"/>
   <view-state id="teilnehmenViewState">
      <on-entry>
          <set name="tfRef" value="requestParameters.tfref" type="java.util.UUID" />
          <evaluate expression="tfNumberHolder.updateRefIfNotNull(tfRef)"/>
          <evaluate expression="teilnehmenController.initialisiereModel(teilnehmenModel)" />
      </on-entry>

      <transition on="save" to="teilnehmenViewState">
          <evaluate expression="teilnehmenController.speichereTeilnehmer(teilnehmenModel)"/>
      </transition>

	  <transition on="saveAllFalse" to="teilnehmenViewState">
          <evaluate expression="teilnehmenController.speichereTeilnehmerAllFalse(teilnehmenModel)"/>
      </transition>
   </view-state>
</flow>
----

Charakteristisch sind hier die folgenden Elemente:

* Flow-Tag mit Deklaration aller verwendeten Taglibs und Namespaces, sowie die Einbindung der
anwendungsübergreifend einheitlichen `parent-Flow`-Definition (enthält global gültige Regeln, Fehler-Handler
und Layoutkonfigurationen).
* Definition des Models unter Angabe der Model-Bean-Klasse als Flow-Variable
* Es wird ein `onStart`-Handler für den Flow definiert.
Das Model sollte immer über die standardisierte Initialisierungsmethode beim Starten des Flows initialisiert werden.
Weiterhin können weitere, spezifische Methoden aufgerufen werden, um z.B. Eingabeparameter in das Model einzuarbeiten.
* Ein View-State, welcher den Hauptzustand des Flow definiert.
Der Name des View-State verknüpft die Komponente auch mit dem gleichnamigen View
(z.B. teilnehmenViewState.xhtml), der automatisch beim Rendern aufgerufen wird.
* Gegebenenfalls weitere View-States, falls die Komponente mehrere Views (z.B. aufeinanderfolgende Eingabemasken
zu einem zu erfassenden Datentyp) verwaltet.
* Für jeden View-State kann ein `onEntry`-Handler definiert werden.
* Für jeden View-State werden die ausgehenden Transitionen im Sinne eines Zustandsautomaten definiert.
Für jede Transition wird ein Zielzustand festgelegt. Diese können sein:
** Der eigene View-State (zur Aktualisierung des Views).
** Ein untergeordneter SubFlow (führt zur Anzeige einer anderen GUI-Komponente). Nach Ausführung des Subflow
kehrt die Anwendung in den aktuellen Flow zurück.
** Ein Action-State oder ein Decision-State, in denen der Flow entweder Aktionen (z.B. Aufrufe des
Anwendungskerns) oder Entscheidungen zum weiteren Flow-Ablauf trifft.
** Keine Angabe eines Zielzustands: Dadurch verbleibt der Flow im aktuellen View-State.
Dieser wird aktualisiert.
Der vorherige Zustand kann NICHT mehr über den Browser-Back-Button erreicht werden.
Für AJAX-Aufrufe, welche nur einen bestimmten Teil der Seite aktualisieren sollen, darf kein Zielzustand
angegeben werden. +
+
Für jede Transition kann hinterlegt werden, ob die Browser-Historie (für Back Button Handling) zurückgesetzt werden soll.
Kommt man also nach Anzeigen einer Trefferliste über das Löschen eines Eintrages wieder zur Trefferliste, so
sollte die Möglichkeit der Bereinigung der Historie genutzt werden.
* Beim Aufruf von Subflows müssen meist Parameter übergeben werden.
Dazu wird ein Input-Tag verwendet, welches ein Schlüssel/Wertpaar an den Subflow übergibt.
Im Subflow wird der Parameter über ein Input-Tag entgegengenommen und steht dann als Flow-Variable
zur Verfügung und sollte im `onStart`-Handler per Controller in das Model übernommen werden. +
+
*Wichtig:* Um die Kapselung der GUI-Komponenten zu bewahren ist es wichtig, dass GUI-Komponenten ihre Parameter
immer über ein Input-Tag erhalten und nicht frei auf fremde Models und Controller zugreifen. +
+
*Wichtig:* Bei der Übergabe eines Parameters (z.B. Liste) ist immer eine Kopie der Datenstruktur zu
übergeben, damit Änderungen an der Datenstruktur durch einen Subflow sich nicht auf den aufrufenden
Flow auswirken.
In diesem Sinne ist auch verboten, ein ganzes Model-Bean zu übergeben.
Müssen mehrere Informationen übergeben werden, so können natürlich auch mehrere Input-Parameter
verwendet werden. +
+
Auch die Rückgabe von Out-Parametern ist über ein Output-Tag möglich.
Es gelten die gleichen Richtlinien wie bei Input-Parametern.
* Ein Decision-State namens `_aktualisieren`, der für technische Zwecke u.a. bei der Fehlerbehandlung verwendet wird.
* An nahezu allen Stellen der Flow-Definition ist der Aufruf von Spring-Beans per `evaluate`-Tag möglich.
Hier wird die Java-Expression-Language verwendet (beachte: es handelt sich hier nicht um die deutlich
leistungsfähigere Spring Expression Language). Genutzt wird die Möglichkeit ausschließlich zum Aufruf
des zustandslosen Controller-Beans – meist unter Bereitstellung des Model-Beans.
Das Ergebnis kann in einer neuen Flow-Variablen hinterlegt werden (was wir aber im Allgemeinen nicht nutzen,
da diese Werte im Model-Bean hinterlegt werden sollten).

Eine Flow-Definition bietet weitaus mehr Möglichkeiten, die aber im Regelfall nicht benötigt und daher hier
nicht erläutert werden.

[[der-controller]]
=== Der Controller

Jede GUI-Komponente verfügt über ein Controller-Bean.
Dieses ist der „verlängerte Arm“ des Flow, denn im Flow kann und soll nicht programmiert werden.
Jegliche zu programmierende GUI-Logik wird im Controller in zustandslosen Methoden bereitgestellt.
Typische Methoden im Controller sind:

* Methoden zur Initialisierung des Models.
* Methoden zum Aufruf des Anwendungskerns.
* Methoden zur Aufbereitung von Daten des Models bevor diese gerendert werden.

Das Controller-Bean wird in der Spring Konfiguration als einfaches Spring-Bean definiert und ist somit im Flow
automatisch sichtbar und nutzbar.

Das Controller-Bean muss von AbstractGuiController erben.

Da das Controller Bean zustandslos ist, muss im Regelfall bei jedem Aufruf das Model mitgeliefert werden.

Der Controller kann auch eine eigene Fehlerbehandlung enthalten, im seltenen Fall auch selbst Meldungen in
den `FlowRequestContext` schreiben, die dann als Fehler- oder Hinweismeldung ausgegeben werden.

Eine Rückgabe von Zielzuständen zur Steuerung des Flow in Methoden des Controllers ist zu vermeiden.
Sinnvoll ist die Rückgabe eines Ergebnistokens (Erfolg oder Fehler), um dann im Flow den Zielzustand festzulegen
und dann anzusteuern.
Solche Entscheidungen können im Flow auch per Action- oder Decision-State umgesetzt werden, wobei im Controller
eine Methode `is…` mit Rückgabewert `boolean` verwendet wird.

Die häufig gesehene Umsetzung von einfachen `geheZu`-Methoden des Controllers, die lediglich einen Rückgabewert
aus einer Konstanten zurückliefern, erbringt keinen Mehrwert.
Der Wert kann auch direkt in der Flow-Definition festgelegt werden.

[[das-model]]
=== Das Model

[[bereitstellung-eines-models]]
==== Bereitstellung eines Models

Wie unter <<der-flow>> beschrieben, wird das Model immer durch einen Flow instanziiert und verwaltet.
Ein Model für eine Maske muss von AbstractMaskenModel erben.

[[befuellen-eines-models]]
==== Befüllen eines Models

Wie unter <<der-controller>> beschrieben, wird das Model durch den Controller bei Bedarf initialisiert und mit Daten aus dem Anwendungskern befüllt.
Auch die Aufbereitung von Daten des Models kann durch den Controller erfolgen (alternativ über View-Konverter). Das Konvertieren von Model-Inhalten durch Logik im Model-Bean soll möglichst vermieden werden.
Insbesondere ist Logik zu vermeiden, bei der Fehler auftreten können.
Ein Model soll vor dem Rendern möglichst alle anzuzeigenden Daten passgenau für das Rendering vorhalten.

[[abgleichen-eines-models]]
==== Abgleichen eines Models

Der Abgleich des Models mit dem View (nach Submit einer Maske) erfolgt automatisch durch JSF.
Alle Seiteninhalte, die beim Rendern aus einem Model gelesen wurden, werden nach dem Submit wieder in das
Model rückübertragen und stehen dann zur weiteren Verarbeitung für den Controller oder erneutes Rendering zur
Verfügung.

[[speichern-der-daten-eines-models]]
==== Speichern der Daten eines Models

**Speichern der Session-Daten**

Das Model-Bean wird vom Flow im Flow Scope gehalten.
Daher wird die Datenstruktur zwischen den einzelnen Dialogschritten in der Session
persistiert (Conversation-Persistierung siehe <<spring-web-flow>>).

Für die Ablage im Flow Scope werden die Daten in serialisierter Form abgelegt.
Daher muss das Model-Bean das Interface Serializable implementieren.

Größere Datenmengen beeinträchtigen die Performance der Anwendung zur Laufzeit.
Umso mehr Daten im Model enthalten sind, desto aufwändiger ist die Session-Persistierung.
Daher ist die Menge an gehaltenen Daten auf das Notwendige zu beschränken.
Model-Members, die nur temporär während der Datenaufbereitung befüllt werden, sollten dringend als „transient“
markiert werden, um diese aus der automatischen Persistierung auszunehmen.

*Hinweis:* Die Session-Persistierung erfolgt neben den Dialogschritten zusätzlich auch beim Redirect im Rahmen
der Anwendung des Post Redirect Get-Pattern (siehe <<back-button-handling>>).

**Speichern der fachlichen Daten**

Die nach einem Submit im Model-Bean gespeicherten (und vom Anwender ggf.
veränderten) Daten werden nach Validierung in die fachlichen Tabellen der Datenbank übernommen.
Dies erfolgt immer durch einen Controller, der die Daten aus dem Model an den Anwendungskern-Wrapper übergibt.

[[der-view]]
=== Der View

[[definition-des-view-state]]
==== Definition des View-State

Jeder View-State in der Flow-Definition der GUI-Komponente ist mit einer eigenen Maske, dem View verknüpft.
Spring Web Flow steuert das Rendering des Views.

Der View einer GUI Komponente ist nach unserem Umsetzungsmuster wie folgt aufgebaut: Eine Facelet-Datei dient
dazu, die im Seitentemplate (siehe <<Einleitung>>) inkludierte Definition der Seitenbereiche des Inhaltsbereiches zu definieren.
Das `<ui:composition>` Tag referenziert hierbei das Seitentemplate, in welchem die über `<ui:define>`
definierten Teile eingebunden werden.
Die verschiedenen Teile des Seitentemplates finden sich in <<Styleguide>>.

:desc-listing-BSPFaceletView: Beispiel Facelet cdErwerbViewState.xhtml
[id="listing-BSPFaceletView",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-BSPFaceletView}
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE composition PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<ui:composition xmlns="http://www.w3.org/1999/xhtml"
                xmlns:ui="http://java.sun.com/jsf/facelets"
                xmlns:h="http://java.sun.com/jsf/html"
                xmlns:f="http://java.sun.com/jsf/core"
                xmlns:sf="http://www.springframework.org/tags/faces"
                template="/WEB-INF/gui/common/layout/applikation.xhtml">

				<ui:define name="title"><h:outputText value="#{msg.MEL_CdErwerben}"/></ui:define>
                <ui:define name="content1">
                <ui:include src="/WEB-INF/gui/cderwerb/cdErwerbUebersicht1.xhtml" />
                </ui:define>
				<ui:define name="content2">
				<ui:include src="/WEB-INF/gui/cderwerb/cdErwerbFormular1.xhtml" />
				</ui:define>
				<ui:define name="buttonzeile">
				<ui:include src="/WEB-INF/gui/cderwerb/cdErwerbButtonzeile1.xhtml" />
				</ui:define>
</ui:composition>
----

Die Seitenbereiche werden im `ViewState`-Facelet wiederum durch Inklusion auf kleinere Facelets umgesetzt.
Das heißt jeder Seitenbereich (Formular, Buttonzeile) wird per Konvention in einer separaten Datei gepflegt.
Innerhalb dieser Facelets wird im Normalfall nichts mehr inkludiert.

:desc-listing-BSPFaceletCDErwerb: Beispiel-Facelet cdErwerbButtonzeile1.xhtml
[id="listing-BSPFaceletCDErwerb",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-BSPFaceletCDErwerb}
[source,xml]
----
<div class="buttonzeile"
	xmlns:h="http://java.sun.com/jsf/html">
	<h:commandButton value="#{msg.MEL_Weiter}" action="weiter" styleClass="btn suchen"></h:commandButton>
	<h:commandButton value="#{msg.MEL_Abbrechen}" action="abbrechen" styleClass="btn suchen"></h:commandButton>
</div>
----

[[rendern-einer-maske-mit-den-daten-eines-models]]
==== Rendern einer Maske mit den Daten eines Models

Der Zugriff auf die Daten des Models erfolgt in den Facelets über die Common Expression Language (EL) <<CommonEL>>.
Das Model ist im View sichtbar, da es im Flow als Flow-Variable deklariert wurde.
Das Model ist zum Zeitpunkt des Renderns bereits mit Daten befüllt, da im `onEntry`-Handler des Flows der
Controller die Befüllung des Models vorgenommen hat.

:desc-listing-DatZuFacelet: Datenzugriff im Facelet
[id="listing-DatZuFacelet",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-DatZuFacelet}
[source,xml]
----
<isy:formInput reference="name" value="#{erstellenModel.name}" label="Titel der Veranstaltung" required="true"/>
----


Es ist wichtig zu verstehen, dass durch das Rendern der Daten aus dem Model eine Bindung der Model-Property
mit dem GUI-Element (im Beispiel ein Form-Input-Feld) hergestellt wird, welches nach Submit des Webformulars
automatisch durch Spring Web Flow in das Model zurücksynchronisiert wird.
Damit das funktioniert ist eine eindeutige HTML-ID zu vergeben.
Die HTML Elemente erhalten entsprechend ihres Inhaltes den Bezeichner des zugehörigen Attributes.
Würde keine ID vergeben, so würde JSF selbständig eine dynamische ID vergeben.
Das erschwert jedoch den automatischen Test der Oberfläche.

:desc-listing-HTMLIDFace: HTML ID Vergabe
[id="listing-HTMLIDFace",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-HTMLIDFace}
[source,xml]
----
<h:selectOneMenu id="vonZeit" value="#{tag.vonZeitraum}" converter="calCon">
                 value="#{erstellenModel.alleZeitraeume}" var="von"
                 itemValue="#{von}" itemLabel="#{von}"/>
----

Werden versehentlich IDs mehrfach verwendet, so sind Fehler bei der Datenübernahme wahrscheinlich.

[[ausloesen-von-aktivitaeten-in-facelets]]
==== Auslösen von Aktivitäten in Facelets

Die Auslösung von Aktion erfolgt über die Nutzung des `action`-Attributes der verwendeten GUI-Komponenten.
Hier wird ein Token verwendet, welches auch im Flow bekannt ist und die Transition so steuert, dass der
Controller die Daten über den Anwendungskern persistiert.

:desc-listing-BSPActions: Beispiele für Actions
[id="listing-BSPActions",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-BSPActions}
[source,xml]
----
<isy:button action="back" value="Zurück"/>
<isy:button action="continue" value="Weiter"/>
----

[[datenkonvertierung-fuer-darstellung-und-eingabe]]
==== Datenkonvertierung für Darstellung und Eingabe

Für die formatierte Darstellung von Daten können JSF-Konverter zur Konvertierung aus der Ansicht ins
typisierte Datenmodell, wie auch zur Umwandlung aus dem Datenmodell in die Ansicht verwendet werden.
Hier bieten sich JSF-Konverter an, die jedoch nur mit Einschränkungen verwendet werden können, da diese
 bei der Konvertierung „freier Eingaben“ nicht mit Fehleingaben umgehen können.

:desc-listing-ConvDatewihConv: Umwandlung eines Datums mittels Konverter
[id="listing-ConvDatewihConv",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-ConvDatewihConv}
[source,xml]
----
<h:inputText id="datum" value="#{erstellenModel.newDate}">
    <f:convertDateTime type="date" />
</h:inputText>
----

Wenn die Validierung in einem JSF-Konverter stattfindet, werden die Daten in einem Fehlerfall nicht ins
Modell geschrieben.
Dies führt dazu, dass das Formular zurückgesetzt wird, weil die Seite wegen des PRG-Patterns mit einem
GET-Request mit dem alten Modell neu geladen wird.
Die ungültigen Eingaben gehen also zusammen mit allen anderen Änderungen im Modell verloren.
Standard-JSF-Konverter sind also faktisch nicht nutzbar.

Ein geeigneter Konverter muss auch ungültige Daten ins Modell schreiben können.
Wenn dies aufgrund der Nutzung spezieller Datentypen (wie z.B. `Date`) nicht möglich ist, muss im View-Model
 der Datentyp `String` verwendet werden.
Die Konvertierung findet in diesem Fall nicht durch einen Konverter statt, sondern erst nach oder während
der Validierung.

Oft ist es notwendig, im Model Schlüssel eines Schlüsselverzeichnisses zu verwenden.
Dieser sollte in der Regel in der Maske nicht als Schlüssel, sondern in einer verständlichen Form dargestellt werden.
Hier bietet sich der Einsatz eines eigenen Konverters an, der mittels Schlüssel-Wert-Mapping die
Umwandlung je nach Verarbeitungsrichtung leistet.
Analog gilt dies auch für Booleans und Aufzählungstypen.

:desc-listing-ConvEnumwithConv: Umwandlung eines Aufzählungstyps mittels Konverter
[id="listing-ConvEnumwithConv",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-ConvEnumwithConv}
[source,xml]
----
<h:outputText value="#{cdAblageDatenBackBean.interpretMaennlich}">
     <f:converter converterId="geschlechtsTypConverter"/>
</h:outputText>
----

Im Hinblick auf aktiviertes JavaScript darf bei `outputText` niemals das Attribut `escape` auf `false`
gesetzt werden.

[[interaktive-elemente-mit-jquery]]
==== Interaktive Elemente mit JQuery

JQuery ist ein mächtiges Framework zur DOM-Manipulation.
Entsprechend vorsichtig und gezielt sollte der Einsatz gewählt werden.
In der Regel bieten die Komponenten des Styleguides <<Styleguide>> Zugriff auf Visualisierungsformen mittels JavaScript (z.B. Kalenderwidget, Tags, Panels). Für bestimme Zusatzanforderungen (z.B. bedingtes Deaktivieren eines Felds, weitere GUI-Verschönerungen) kann es jedoch notwendig sein zusätzliches JavaScript einzubinden.

Die View-spezifische Funktionalität wird in einer eigenen JavaScript-Datei umgesetzt.
Dabei sind grundsätzlich folgende Regeln zu beachten:

:desc-table-RuleViewFkt: Regeln für View spezifische Funktionalitäten
[id="table-RuleViewFkt",reftext="{table-caption} {counter:tables}"]
.{desc-table-RuleViewFkt}
[cols="4,5",options="header"]
|====
|Regel |Begründung / Beispiel
|`eval()` darf nicht verwendet werden a|
Die Verwendung von `eval()` stellt ein Sicherheitsrisiko da.
Es besteht die Gefahr, dass Werte aus Request-Parametern ohne ausreichende Prüfung als Code ausgeführt werden.
Beispiel:

[source,javascript]
----
var requestValue = getParameterValueForParameter
  (“searchString“);
eval(requestValue)
----

Dies ermöglicht es jeden beliebigen JavaScript Code per Injektion auf einem Client ausführen zu lassen.
Ein Angreifer könnte dann Code auf dem Server wie folgt einschleusen:

[source,html]
----
www.mySite.de?searchString=alert(‚hallo‘)
----
a|
`setTimeout()` darf nicht in der Variante aufgerufen werden, die den Code in einer Zeichenfolge enthält.
Stattdessen muss ein `function()`-Parameter übergeben werden:

[source,javascript]
----
setTimeout(
function() {
…
}
, 100)
----
 a|
Die verbotenen Varianten von `setTimeout()` stellen ebenfalls ein Sicherheitsproblem da.
Die Angriffsmöglichkeit ist jedoch weniger offensichtlich.
Beispiel:

[source,javascript]
----
setTimeout(“callSomeSpecialFunktion
  (searchString)“, 100);
----

Ein Angreifer könnte nun eine URL wie folgt aufrufen:

[source,html]
----
www.mySite.de?searchString=5
  );alert(‚hallo‘
----

Der Inhalt der Variable „searchString“ wird im searchString ersetzt, so dass folgender Code ausgeführt würde:

[source,javascript]
----
setTimeout(“callSomeSpecialFunktion
  (5);alert(“hallo“), 100);
----

Der Angreifer hätte es also geschafft die Ausführung der Funktion `alert(“hallo“)` auf dem Server zu veranlassen.
|Sofern keine Wiederverwendung möglich ist, ist von der Definition benannter Funktionen abzusehen und anonyme Funktionen einzusetzen.
Dies betrifft im speziellen das Event-Binding
 a|
Definierte JavaScript-Funktionen sind in der Regel im globalen Variablen-Kontext gültig.

Würde für jede Callback-Funktion eine eigene Funktion definiert, würde das den Speicher unnötig belasten.

Weiterhin verschlechtert sich die Lesbarkeit.
Gerade bei Callbacks ist es nützlich wenn direkt ersichtlich ist, was passiert wenn der Callback aufgerufen wird.

Weiterhin können anonyme Funktionen auf Variablen der umgebenen Funktion zugreifen, was die Implementierung vereinfacht:

[source,javascript]
----
var einWert=5;
setTimeout(
  function {
  alert(4 + einWert);
}
, 100);
----
a|
Benannte Funktionen sollten in einem Namespace deklariert werden, die eine Zuordnung zu einem View erkennen lässt:
[source,javascript]
----
var ns_<view> = {
foo : function() { … }
}
----
 |Wie bereits beschrieben gelten Funktionen häufig im globalen Kontext.
Funktionsnamen können wie Variablen durch redundante Deklaration leicht versehentlich überschrieben werden.
Dann gilt immer die letzte Definition.
Die Verwendung des View-Names als „Namespace“ vermeidet, Funktionen aus einem anderen View versehentlich zu „überschreiben“.
a|
Jede JavaScript-Datei beginnt mit
[source,javascript]
----
(function(){
----
und endet mit
[source,JavaScript]
----
})()
----
Die Deklaration von Wiederverwendbaren Funktion- bzw.
Namespace-Definitionen müssen außerhalb dieses Blocks erfolgen.
 |Mit diesem Konstrukt wird verhindert, dass (versehentlich) neue Funktions- und Variablen-Definitionen Elemente aus dem globalen Kontext überschreiben.
|Inline-JavaScript ist zu vermeiden.
a|
Es gibt Fälle in denen JavaScript „inline“ technisch bedingt direkt in der XHTML-View-Definition implementiert werden muss.
Hier besteht die Gefahr, dass der JS-Script-Code schlecht strukturiert und auf zu viele Dateien verteilt wird.

Zudem ist JavaScript-Code in XHTML-Dateien unerwartet und wird bei der Analyse der Anwendung schnell übersehen.
Insgesamt wird hierdurch die Verständlichkeit und Wartbarkeit der Anwendung verschlechtert.

|Der DOM-Zugriff mit der +
$-Funktion sollte stets über die Id oder Klasse eines DOM-Knotens erfolgen und nicht über die
Knotenhierarchie des DOMs.
a|
[source,javascript]
----
$(„#eineBildID“);   // GUT
$(„div span a img“);// SCHLECHT
----

Die Gefahr bei letzterer Variante ist die Fehleranfälligkeit auf Änderungen in der DOM-Struktur.
Wird z.B. ein weiteres DIV eingefügt, greift die Funktion ggf.
nicht und die Anwendung arbeitet fehlerhaft.

|Event-Binding erfolgt im JavaScript-Code und nicht in den on<Event>-Attributen des HTML-Elementes. |Das Event-Binding in den on<Event>-Attributen erzeugt Inline-JavaScript, dass stets zu vermeiden ist (s.o.)
|Im JavaScript-Code dürfen Request- oder URL-Parameter nur nach ausreichendem encodieren und escapen verwendet werden.
Gleiches gilt für den Einsatz von Server-Parametern bzw.
Model-Attributen.
a|
Auch hier besteht ein Sicherheitsrisiko.
Wird Beispielsweise ein Suchstring wie folgt in die Seite eingebunden:
[source,xml]
----
<title>${searchStringFromRequest}</title>
----
Ein Angreifer könnte dann folgende URL aufrufen:
[source,html]
----
www.mySite.de?searchString=
   <script>alert(‚halloWelt‘)</script>
----
Der übergebene JavaScript-Block würde dann auf dem Server ausgeführt.
Das Escapen „zerstört“ die spitzen Klammern und Hochkommata, so dass kein Code ausgeführt wird.
|====

[[clientseitige-validierung-von-eingaben]]
==== Clientseitige Validierung von Eingaben

Zur clientseitigen Validierung von Eingaben wird das jQuery Validation Plugin verwendet.
Die Markierung von Pflichtfeldern und die Definition von eigenen Regeln und Hinweistexten ist
unter http://blogs.fau.de/webworking/2011/05/13/tutorial-zur-eingabevalidierung-von-formularen-mit-hilfe-von-jquery/
beschrieben. Der Aufruf erfolgt dabei innerhalb der View-spezifischen JavaScript-Datei über die ID des
Formulars: `$("#formular").validate();`

Da JavaScript deaktivierbar und manipulierbar ist, müssen grundsätzlich alle Validierungen
auch serverseitig erfolgen.

[[serverseitige-validierung-von-eingaben]]
==== Serverseitige Validierung von Eingaben

Die Validierung und Prüfung der in der GUI erfassten Daten soll entweder vollständig durch die GUI oder
aber vollständig im Anwendungskern durchgeführt werden.
Die Validierung in der GUI ist dabei bevorzugt.
In diesem Falle wird der Validierungsmechanismus von Spring Web Flow verwendet.
(Abschnitt 5.10 - Validating a model in <<SWF>>).

Die JSF-Validatoren oder JSF-Konverter sollten für die Validierung aus den im Abschnitt
<<datenkonvertierung-fuer-darstellung-und-eingabe>> genannten
Gründen nicht verwendet werden.

Sind im Datenmodell Datentyp wie Datum, Zeit oder Zeitpunkt enthalten, und diese auch durch den Benutzer
der GUI frei eingebbar, so ist es am einfachsten, im Model ein String-Feld zu verwenden und die
Konvertierung und Validierung im selbst programmierten Spring Web Flow-Validator durchzuführen.

[[darstellung-von-fehlern]]
==== Darstellung von Fehlern

Das folgende JSF-Tag `message` kommt zum Einsatz, um einen Fehler für ein bestimmtes Feld anzuzeigen:

:desc-listing-BspFaceletError: Beispiel aus Facelet
[id="listing-BspFaceletError",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-BspFaceletError}
[source,html]
----
<h:message for="isbn" showDetail="false" errorClass="error"/>
----

Das obige JSF Tag markiert das Feld, das die JSF-ID „isbn“ hat, als fehlerhaft, wenn im JSF-Context eine
 Fehlernachricht für die JSF-ID „isbn“ geschrieben wurde.

Für die Darstellung aller Fehlermeldungen kommt das JSF Tag `messages` zum Einsatz.
Hierdurch werden alle Fehler, unabhängig von ihren JSF-IDs, in einer Liste dargestellt:

:desc-listing-DarstError: Darstellung von Fehlermeldungen
[id="listing-DarstError",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-DarstError}
[source,html]
----
<h:messages/>
----

Die Darstellung von Fehlern und Validierungsnachrichten wird auch im Styleguide <<Styleguide>> beschrieben.

[[verwendung-von-jsf-widgets]]
==== Verwendung von JSF Widgets

Für die Arbeit mit JSF werden einige Komponenten/Widgets bereits vorab zur Verfügung gestellt.
Die Widgets sind alle als JSF Composite Components realisiert.
Dadurch ist eine einfachere Wartung möglich, da die Komponenten vollständig in XHTML definiert sind und
ein Grundverständnis von JSF genügt, um Anpassungen vorzunehmen.
Spezielle Renderer oder Java-Klassen werden nicht benötigt.
Details hierzu sind im Styleguide <<Styleguide>> zu finden.

Für die Verwendung der Tags muss in den XHTMLs folgender Namespace eingebunden werden:

`xmlns:isy="http://java.sun.com/jsf/composite/isyfact"`

[[einsatz-von-action-listenern]]
==== Einsatz von Action Listenern

Action Listener können dazu verwendet werden, um auf das Klicken eines Buttons oder Links innerhalb einer Seite zu reagieren.

Auf Grund einer Eigenart von JSF in Zusammenhang mit dem Partial-State-Saving muss unbedingt darauf geachtet werden, dass die Komponente (Button/Link), an die der Action Listener gebunden ist und nicht durch den Klick ausgeblendet wird.
Andernfalls führt dies zu Problemen mit dem Loadbalancing.
Hintergrund ist, dass JSF durch das Partial-State-Saving den Maskenzustand teilweise in der Serversession ablegt.
Werden die Anfragen an die Webanwendung durch den Loadbalancer an verschiedene Server verteilt, kann dies daher dazu führen, dass JSF eine Exception wirft, weil der Action Listener der ausgeblendeten Komponente nicht gefunden werden konnte.

[[parameter-mit-buttonlink-uebergeben]]
==== Parameter mit Button/Link übergeben

JSF bietet mehrere Möglichkeiten, einen Parameter in Abhängigkeit eines geklickten Buttons oder Links an
die Webanwendung zu übergeben.
Dies ist beispielsweise dann notwendig, wenn auf einer Maske mehrere Elemente angezeigt werden, zu denen
jeweils ein eigener „bearbeiten“-Button existiert.
In diesem Fall muss es möglich sein zu erkennen, welcher Button zu welchem Element geklickt worden ist.

Die hierfür in JSF 2.x vorgesehenen Lösung mit `f:param` erfordert den Einsatz von JavaScript und
kann daher Probleme in der Abwärtskompatibilität hervorbringen (z.B. wenn kein JavaScript aktiviert ist).
 Die Umsetzung sollte daher in der Regel mit einem Action Listener stattfinden (siehe <<listing-UseActionListVIEW>>):

:desc-listing-UseActionListVIEW: Verwendung eines Action Listeners (View)
[id="listing-UseActionListVIEW",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-UseActionListVIEW}
[source,html]
----
<h:commandLink id="bearbeite_SV_#{sachverhalt.id}" value="#{msg.MEL_Bearbeiten}" actionListener="#{listener.waehleSachverhalt}">
    <f:attribute name="sachverhaltId" value="#{sachverhalt.id}" />
    ...
</h:commandLink>
----

:desc-listing-EvalRequestAttr: Auswertung von Request Attributen
[id="listing-EvalRequestAttr",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-EvalRequestAttr}
[source,html]
----
FacesContext.getCurrentInstance().getExternalContext() .getRequestParameterMap().get("sachverhaltId");
----

Dabei kann in der Methode `waehleSachverhalt`, der Wert des Attributs aus der `RequestParameterMap` des
`FacesContextes` gelesen werden (siehe <<listing-EvalRequestAttr>>). Beim Einsatz des Action Listeners
muss darauf geachtet werden, dass die Komponente (Button/Link), an die der Action Listener gebunden ist,
nicht durch den Klick ausgeblendet wird (vgl. Abschnitt <<einsatz-von-action-listenern>>).

Als Alternative zum Einsatz eines Action Listeners, kann die ID des Buttons/Links parametrisiert und im
Controller ausgewertet werden. Die Parametrisierung der ID wird ebenfalls in <<listing-UseActionListVIEW>> dargestellt.
Die Auswertung ist in diesem Fall aufwendiger, da alle Attribute der `RequestParameterMap` durchlaufen
werden müssen, bis ein Parameter gefunden wurde, dessen ID mit „bearbeite_SV_“ beginnt.
Vorteil der Lösung ist jedoch, dass Probleme mit dem Einsatz von Action Listenern damit umgangen werden.

[[allgemeines]]
== Allgemeine Vorgaben

[[festlegung-der-startseite]]
=== Festlegung der Startseite

Für den initialen Zugriff auf die Applikation wird in der `web.xml` der Startpunkt für den Dialogablauf definiert.
Dieses geschieht durch den Eintrag in der `<welcome-file-list>` auf ein Index File, in welchem der
Redirect auf den Web Flow steht.
Dieses ist notwendig, weil eine Angabe der Flow Engine im `web.xml` für Welcome Files nicht möglich ist.

:desc-listing-Snipwebxml: Ausschnitt web.xml
[id="listing-Snipwebxml",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-Snipwebxml}
[source,html]
----
<welcome-file-list>
      <welcome-file>index.html</welcome-file>
</welcome-file-list>
----

Der Auszug aus der Datei `index.html` sieht folgendermaßen aus:

:desc-listing-SnipIndexxml: Ausschnitt index.html
[id="listing-SnipIndexxml",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-SnipIndexxml}
[source,html]
----
<html>
    <head>
        <meta http-equiv="Refresh"
            content="0; URL= app/startFlow">
    </head>
</html>
----

[[der-allgemeine-seitenrahmen]]
=== Der allgemeine Seitenrahmen

Der Aufbau und die Einbindung des allgemeinen Seitenrahmens ist im Styleguide <<Styleguide>> beschrieben.

[[anpassung-seitenrahmen]]
=== Anpassung des Seitenrahmens
Anwendungen können den Seitenrahmen bis zu einem gewissen Grad optisch an ihre Anforderungen anpassen.

==== Logos, Texte und Farben
Es besteht die Möglichkeit, für jeden Flow die folgenden Teile des Seitenrahmens anzupassen:

- Linkes Logo im Header (`gui.header.logo.links.pfad`)
- Rechtes Logo im Header (`gui.header.logo.rechts.pfad`)
- Text unterhalb des rechten Logos im Header (`gui.header.text.logo.rechts`)
- Farbwert der Anwendungsgruppe (`gui.anwendungsgruppe.farbwert`)

Um hiervon Gebrauch zu machen, muss die entsprechende Konfigurationsdatei über die Bean-Definition eingebunden werden:

:desc-listing-anpassung-rahmen-config: Konfigurationsdatei zur Anpassung des Seitenrahmens einbinden
[id="listing-anpassung-rahmen-config",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-anpassung-rahmen-config}
[source,xml]
----
<beans>
    ...
    <bean id="konfiguration" ...>
        <constructor-arg>
            <list>
                ...
                <value>/resources/gui-anwendungsgruppen.properties</value>
                ...
            </list>
        </constructor-arg>
    </bean>
    ...
</beans>
----

Anwendung können globale Standardwerte definieren. Definieren sie diese nicht, verwendet der Seitenrahmen Standardwerte aus `isy-web`.

:desc-table-SeitenrahmenStandardwerte: Globale Standardwerte für den Seitenrahmen
[id="table-SeitenrahmenStandardwerte",reftext="{table-caption} {counter:tables}"]
.{desc-table-SeitenrahmenStandardwerte}
[cols="5,4",options="header"]
|====
|Parameter                      |Standardwert
|`gui.header.logo.links.pfad`   |kein Logo
|`gui.header.logo.rechts.pfad`  |kein Logo
|`gui.header.text.logo.rechts`  |kein Text
|`gui.anwendungsgruppe.farbwert`|image:anwendungsgruppe-standardfarbe.png[width=25]
|====

Die gleichen Werte können Anwendungen zusätzlich auf Ebene sogenannter _Anwendungsgruppen_ setzen, um den Seitenrahmen noch weiter an ihre Anforderungen anzupassen.
Anwendungsgruppen fassen in der Regel mehrere Flows zusammen und spiegeln sich nicht selten direkt in der Hauptnavigation wieder.
Setzt die Anwendungen einzelne Werte für bestimmte Anwendungsgruppen nicht, werden die globalen Standardwerte (s. <<table-SeitenrahmenStandardwerte,vorige Tabelle>>) herangezogen.

:desc-table-SeitenrahmenStandardwerteGruppen: Standardwerte für den Seitenrahmen bezogen auf Anwendungsgruppen
[id="table-SeitenrahmenStandardwerteGruppen",reftext="{table-caption} {counter:tables}"]
.{desc-table-SeitenrahmenStandardwerteGruppen}
[cols="5,4",options="header"]
|====
|Parameter                                         |Standardwert
|`gui.header.logo.links.pfad.<anwendungsgruppe>`   |`gui.header.logo.links`
|`gui.header.logo.rechts.pfad.<anwendungsgruppe>`  |`gui.header.logo.rechts`
|`gui.header.text.logo.rechts.<anwendungsgruppe>`  |`gui.header.text.logo.rechts`
|`gui.anwendungsgruppe.farbwert.<anwendungsgruppe>`|`gui.anwendungsgruppe.farbwert`
|====

Das folgende Beispiel zeigt eine vollständige Konfiguration.

:desc-listing-AnpassungSeitenrahmen: Konfiguration zur Anpassung des Seitenrahmens
[id="listing-AnpassungSeitenrahmen",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-AnpassungSeitenrahmen}
[source]
----
# Globale Standardwerte
gui.header.logo.links.pfad = /javax.faces.resource/img/isyfactschriftzug.jpeg
gui.header.logo.rechts.pfad = /javax.faces.resource/img/isyfactlogo.jpeg
gui.header.text.logo.rechts = IsyFact
gui.anwendungsgruppe.farbwert = #337299

# Defintion der Anwendungsgruppen
gui.anwendungsgruppen.ids = gruppeEins,gruppeZwei,gruppeDrei

# Zuordnung von Flows zu Anwendungdgruppen
gui.anwendungsgruppen.urls.gruppeEins = startseiteFlow,nachrichtenFlow
gui.anwendungsgruppen.urls.gruppeZwei = formulareFlow,beispiellinkFlow
gui.anwendungsgruppen.urls.gruppeDrei = validierungFlow,wizardDialogFlow

# Farbwerte der Anwendungsgruppen
gui.anwendungsgruppe.farbwert.gruppeEins = #46c095
gui.anwendungsgruppe.farbwert.gruppeZwei = #887299
gui.anwendungsgruppe.farbwert.gruppeDrei = #ffbbe1

# Logos / Texte der Anwendungsgruppen
gui.header.logo.links.pfad.gruppeZwei = /javax.faces.resource/img/andererschriftzug.jpeg
gui.header.logo.rechts.pfad.gruppeZwei = /javax.faces.resource/img/andereslogo.jpeg
gui.header.text.logo.rechts.gruppeZwei = Zweite Gruppe
----

[[behandlung-von-fehlern]]
=== Behandlung von Fehlern

In diesem Kapitel wird die Behandlung von Fehlern beschrieben.
Dabei sind folgende Arten von Fehlern zu unterscheiden:

* Validierungsfehler

* Exceptions innerhalb des Dialogablaufs (AWK)
* Exceptions innerhalb des Dialogablaufs (GUI)
* Exceptions außerhalb des Dialogablaufs
* Exceptions innerhalb des Clients

[[umgang-mit-validierungsfehlern]]
==== Umgang mit Validierungsfehlern

Um Validierungsfehler innerhalb der Masken bei den fehlerhaften Feldern darzustellen, besitzt jede
Formularkomponente ein „reference“ Attribut (siehe <<Styleguide>>). Dadurch können Validierungsfehler
den entsprechenden Feldern zugeordnet werden.

Die eigentliche Validierung der Eingabedaten sollte im Anwendungskern erfolgen (z.B. durch Nutzung der Bibliothek `rf-validation`).

In bestimmten Fällen kann es auch notwendig sein zusätzliche Validierungsprüfungen in der GUI Schicht
bereitzustellen (z.B. wenn die GUI je nach Eingabe unterschiedliche AWK-Aufrufe durchführt).
Diese sollten durch einen evaluate-Aufruf über Webflow vor dem eigentlichen Zustandsübergang durchgeführt werden.
Die Nutzung des Spring Webflow Validierungsmechanismus ist grundsätzlich möglich, bringt jedoch auch
Nachteile mit sich, da der Aufruf der Validierung auf einer Namenskonvention von Viewstate und
Transition beruht und bei Namensanpassungen sehr fehleranfällig ist.
Durch den Aufruf der Validierung mit evaluate, wird die Validierung daher explizit und sichtbar definiert.

Bei der Übermittlung von Werten in JSF müssen die Vorgaben aus Kapitel
<<datenkonvertierung-fuer-darstellung-und-eingabe>> beachtet werden:
Die Eingabe von ungültigen Werten (z.B. ungültiges Datum, Buchstaben in einem Zahlenfeld)
muss grundsätzlich möglich sein.
Ggf.
müssen entsprechende Datentypen und JSF-Converters erzeugt werden.
Die Validierung (im AWK oder in der GUI) sollte die Fehleingabe dann feststellen.
Die Validierung über JSF ist derzeit nicht vorgesehen (keine Unterstützung durch den Styleguide).

[[behandlung-von-exceptions-innerhalb-der-verarbeitung-im-awk]]
==== Behandlung von Exceptions innerhalb der Verarbeitung im AWK

Innerhalb der Verarbeitung von Dialogaktionen können Exceptions auftreten.
Sofern diese nicht ohnehin behandelt werden, müssen sie innerhalb der GUI-Schicht behandelt werden.
Der jeweilige Controller muss dabei durch eine Exception-Fassade (try/catch) sicherstellen, dass
auftretende Fehler nicht in die Dialogsteuerung weitergegeben werden.
Der Styleguide <<Styleguide>> bietet dazu Hilfsmethoden zum Loggen und zur Anzeige von Fehlern an.
Das dort implementierte Exception Handling unterscheidet fachliche und technische Exceptions.
Während fachlicher Fehler mit einer möglichst aussagekräftigen Fehlermeldung in der Oberfläche
angezeigt werden sollen, soll für technische Fehler nur eine allgemeine Fehlermeldung angezeigt werden.

Ausgabe für fachliche Exceptions +
im Error-LOG und der GUI: *Fehler-ID + Fehlernachricht + UUID*

Weil die Fehlertexte der fachlichen Fehler in der GUI angezeigt werden, ist die Verwendung von
spezialisierten Exceptions anzuraten, die Fehlertexte enthalten, die für die Anzeige in der GUI geeignet sind.
Hierzu finden sich weitere Informationen im Dokument <<KonzeptFehlerbehandlung>>.

Ausgabe für technische Exceptions +
im Error-LOG: *Fehler-ID + Fehlernachricht + UUID*

in der GUI: *„Es ist ein technischer Fehler aufgetreten (Fehler-ID). Bitte versuchen Sie es später
noch einmal (Referenzcode: UUID).*

In der Oberfläche wird also für technische Fehler immer ein fester Standardtext, zusammen mit
dem „echten“ Fehlercode ausgegeben.
Nur das Error-Log enthält die „echte“ Fehlermeldung.
Dadurch wird verhindert, dass interne oder nur für die Systementwicklung oder den Betrieb relevante
Meldungen nach außen getragen werden.

[[behandlung-von-exceptions-innerhalb-des-dialogablaufs]]
==== Behandlung von Exceptions innerhalb des Dialogablaufs

Exceptions, welche während der Ausführung von Logik der GUI-Schicht (z.B. Datenaufbereitung,
Rendering) entstehen, werden immer als technische Ausnahmefehler angesehen.
Für diese wird eine standardisierte Fehlerseite mit der in Punkt
<<behandlung-von-exceptions-innerhalb-des-dialogablaufs>> angegebenen
Fehlermeldung für technische Fehler ausgegeben.

Um die entsprechende Behandlung solcher Fehler zu ermöglichen, müssen folgende Schritte durchgeführt werden

* Für alle Flows muss ein globaler Übergang auf die Fehlerseite eingerichtet
werden

:desc-listing-flowtransitionOnException: Flow Übergang auf Fehlerseite
[id="listing-flowtransitionOnException",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-flowtransitionOnException}
[source,xml]
----
<transition on-exception="java.lang.Exception" to="fehler"/>
----
* In der `faces-config.xml` muss der JSF Exception Handler konfiguriert werden:

:desc-listing-flowExceptionHandlerKonfiguration: Flow JSF Exception Handler Konfiguration
[id="listing-flowExceptionHandlerKonfiguration",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-flowExceptionHandlerKonfiguration}
[source,xml]
----
<factory>
   <exception-handler-factory>
      de.bund.bva.isyfact.common.web.exception.web.JsfExceptionHandlerFactory
   </exception-handler-factory>
</factory>
----
* Die Fehlerseite (`errorFlow`) muss zur Verfügung gestellt werden.

Bei Nutzung der Bibliothek `isy-web` entfallen diese Schritte, da dies automatisch passiert.

[[behandlung-von-exceptions-außerhalb-des-dialogablaufs]]
==== Behandlung von Exceptions außerhalb des Dialogablaufs

Es gibt Exceptions, die außerhalb des “normalen“ Dialogablaufs auftreten.
Beispiele dazu sind fehlende Flow-Definitionen, abgelaufene Sessions und Autorisierungsfehler.
Solche Fehler werden im Rahmen der HTTP-Request-Bearbeitung durch einen `ExceptionResolver` behandelt.
Hierfür stellt Spring Web Flow einen Handler zur Verfügung, über welchen ein Mapping der Fehler
auf spezielle Fehlerseiten möglich ist.

Es gibt keine anwendungsspezifischen Fehlerseiten.
Alle IsyFact-Anwendungen verwenden eine einheitliche Fehlerseite.

Die Fehlerseite gibt aus Sicherheitsgründen keine Informationen über die Art des Fehlers preis.
Die eigentliche Fehlerursache kann nur aus den Server-Logs ermittelt werden.

Die Fehlerbehandlung wird in der Spring Konfiguration konfiguriert:

:desc-listing-SnipConfigxml30: Ausschnitt aus config.xml
[id="listing-SnipConfigxml30",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-SnipConfigxml30}
[source,xml]
----
<!-- Exception handlers for web flow -->
<bean id="simpleMappingExceptionResolver"
class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
  <property name="defaultErrorView" value="errors/error" />
  <property name="exceptionMappings">
    <props>
       <!-- Thrown when no flow definition was found during a
	        lookup operation by a flow locator. -->
       <prop key="org.springframework.Web Flow.execution.repository.NoSuchFlowExecutionException">errors/flowException</prop>

	   <!-- This might occur if the conversation ended, expired,
	        or was otherwise invalidated, but a client view still
			references it. -->
       <prop key="org.springframework.Web Flow.conversation.NoSuchConversationException">errors/convoException</prop>
    </props>
  </property>
</bean>
----

[[behandlung-von-exceptions-innerhalb-des-clients]]
==== Behandlung von Exceptions innerhalb des Clients

Durch die Nutzung von AJAX entstehen clientseitige HTTP-Requests, welche durch die JSF-JavaScript
Bibliothek gesteuert werden.
Auftretende Fehler (z.B. Server nicht erreichbar, Serverfehler) werden daher nicht durch den Browser
direkt, sondern durch die JS Bibliothek behandelt.

[[sicherheit]]
== Sicherheit

Die Absicherung von Masken erfolgt auf Dialogablauf-Ebene.
Die Berechtigungsprüfung verwendet die Sicherheits-Komponente.

Gekapselt werden die Bestandteile der Sicherheits-Komponente hinter Spring Security.
Durch den Einsatz von Spring Security ist es einfacher eine Integration der Berechtigungen in die Spring
Umgebung, insbesondere Spring Web Flow, zu erreichen.

[[autorisierung]]
=== Autorisierung

Für die Absicherung von Dialogabläufen wird innerhalb der Spring Web Flow Konfiguration auf dem `<view-state>`
ein `<secured>` Tag mit dem geforderten Recht gesetzt.
Die verwendeten Rechte müssen durch die Rollenrechte-Konfiguration (siehe <<NutzungsvorgabenSicherheit>>)
für den eingeloggten
Benutzer entsprechend gesetzt werden.
Durch die Verwendung des Tags wird vor dem Anzeigen des `<view-state>` eine Überprüfung der
Berechtigung des anfragenden Benutzers durchgeführt.
Fehlt dem Benutzer diese, wird die Fehlerseite angezeigt.

:desc-listing-Snipcreateflow: Ausschnitt aus Flow erstellenFlow.xml
[id="listing-Snipcreateflow",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-Snipcreateflow}
[source,xml]
----
<view-state id="erstellenViewState1" model="erstellenModel">
    <secured attributes="Erstellen"/>
    <transition on="continue" to="validiereStammdaten"/>
    <transition on="add" to="erstellenViewState1">
    ...
</view-state>
----

:desc-listing-Snipflowmanage: Ausschnitt aus Flow verwaltenFlow.xml
[id="listing-Snipflowmanage",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-Snipflowmanage}
[source,xml]
----
<view-state id="verwaltenViewState">
    <secured attributes="Verwalten"/>
    <transition on="abschliessen" o="abschliessenViewState"/>
    <transition on="loeschen" to="loeschenViewState" />
    ...
</view-state>
----

[[berechtigungsabhaengige-darstellung-in-masken]]
=== Berechtigungsabhängige Darstellung in Masken

//S 46 / 642  1990

Um eine berechtigungsabhängige Darstellung von Maskenelementen zu realisieren, muss die Anwendung einen Controller
bereitstellen, mit dessen Hilfe über nicht parametrisierte Methoden Anfragen nach den benötigten Rechten gestellt werden können.
Dieser Controller ist dafür zuständig, den Rechte-Schlüssel aufzulösen und die Anfrage an die Komponente Sicherheit zu delegieren.
Beantwortet werden die Anfragen stets mit einem einfachen Booleschen Wert.

Mit Hilfe dieses Controllers lassen sich einzelne Maskenelemente, aber auch Gruppen von Maskenelementen berechtigungsabhängig ausblenden.
Die JSF-Komponenten bietet hierfür das `rendered`-Attribut (siehe <<listing-HideJSFComp>>). Beantwortet der BerechtigungsController den
Methoden-Aufruf von `getBenutzerDarfAdministrieren()` mit `false`, so wird der Button nicht dargestellt.

:desc-listing-HideJSFComp: JSF-Komponente berechtigungsabhängig ausblenden
[id="listing-HideJSFComp",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-HideJSFComp}
[source,xml]
----
<t:commandButton ... rendered="#{berechtigungsController.benutzerDarfAdministrieren}"/>
----

Sollen mehrere oder nicht-JSF Komponenten berechtigungs­abhängig ausgeblendet werden, kann das Fragment-Tag der
Facelets-Bibliothek verwendet werden.
Dieses kann eine beliebige Anzahl an weiteren Maskenelementen umschließen und bietet ebenfalls das `rendered`-Attribut,
welches sich dann auf alle enthaltenen Komponenten auswirkt (siehe <<listing-HideGUIComp>>).

:desc-listing-HideGUIComp: GUI-Komponenten berechtigungsabhängig ausblenden
[id="listing-HideGUIComp",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-HideGUIComp}
[source,xml]
----
<ui:fragment +
   rendered="#{berechtigungsController.benutzerDarfAnwenderAdministrieren}">
           […] weitere Komponenten […]
</ui:fragment>
----

[[vermeidung-von-sicherheitsluecken-bei-aktiviertem-javascript]]
=== Vermeidung von Sicherheitslücken bei aktiviertem JavaScript

Ist JavaScript in einem Browser aktiviert, eröffnet dies gewisse Risiken bei der Verarbeitung datenschutzbedenklicher Informationen.
Folgende Maßnahmen reduzieren jedoch das Risiko möglicher Attacken für Cross-site-Scripting (XSS):

* *Verwendung von Standardbrowsern*: Die gängigen Browser befolgen festgelegte Sicherheitsrichtlinien, die nur schwer und
vorsätzlich deaktiviert werden können.
Diese Standard­einstellungen erschweren XSS und sind gerade für den folgenden Punkt unerlässlich.
* *Übertragung aller Inhalte per HTTPS zum Browser*: Werden Webinhalte per HTTPS zum Client übertragen, ist ein unerwünschtes
Datenauslesen per JavaScript-Injection oder IFrame-Injection verhindert, da Browser JavaScript-Code nur dann auf einen
domain-fremden DOM zugreifen lassen, sofern dieser nicht sicher übertragen wurde.
* *Keine Verwendung von Request-Variablen in offenem JS*: Werden Request-Parameter, z.B. als Teile eines Formulars,
direkt in offenem JavaScript (`eval([var])` oder `setTimeout([var])`) weiterverwendet, so können Angreifer manipulierte
Parameter für DOM-based-XSS nutzen, d.h. es werden JavaScript Befehle als Parameter übergeben, die Inhalte verändern,
auslesen oder in einen falschen Kontext setzen.
* *Encodierung von Request-Variablen im DOM*: Werden Request-Variablen auf einer Seite dargestellt, so sind diese
XML-encodiert einzubinden (siehe Element `outputText` in Kapitel <<datenkonvertierung-fuer-darstellung-und-eingabe>>).
Somit wird verhindert, dass ein Angreifer ein ungewünschtes Script-Tag übergibt.

[[druck-von-masken]]
== Druck von Masken

Für den Druck von Masken wird ein eigenes Stylesheet verwendet.
In diesem Stylesheet kann die Anzeige für den Druck optimiert aufbereitet werden, z.B. in dem das Menü ausgeblendet wird.

Für die Druckvorschau einer Seite sollten die benutzten Widgets so aufbereitet werden, dass alle Inhalte auf der Seite
angezeigt werden (z.B. bei Tabs alle Tabs anzeigen).

Der Styleguide <<Styleguide>> stellt eine entsprechende Druckansicht zur Verfügung.

[[temporaere-binaerdaten]]
== Temporäre Binärdaten

Für manche Anwendungsfälle in Webanwendungen wird ein Speicherort für temporäre Binärdaten benötigt.
Dies ist z.B. notwendig, um dem Nutzer die Binärdaten wieder zur Verfügung zu stellen, bevor diese in einem Datenbestand
gespeichert wurden (z.B. hochgeladenes Lichtbild anzeigen).

TIP: Für (temporäre) Binärdaten kann der RegisterFactory-Binärdatenservice genutzt werden.
Dieser bietet die Möglichkeit Binärdaten entgegenzunehmen und einen Cleanup-Timertask, der veraltete Binärdaten
automatisch wieder aufräumt.
Somit ist keine Verwendung von Datenbankmitteln notwendig.

[[jsf-webgui-demoanwendung]]
== JSF WebGui Demoanwendung

Die isy-webgui ist eine kleine Beispielanwendung, die die Java-Bibliotheken isy-web und isy-style einsetzt.
Die Anwendung zeigt die Features der JSP Komponenten-Bibliothek der isy-web beispielhaft.
Bei Änderungen an der isy-web und der isy-style wird die isy-webgui kontinuierlich aktualisiert.


[[jsf-webgui-implementierungshinweise]]
== JSF WebGui Implementierungshinweise

=== JSF Bedienelemente

Als Bedienelemente für die WebGui werden JSF Composite Components zur Verfügung gestellt.
Durch das Einbinden des JSF Namespace `xmlns:isy="http://java.sun.com/jsf/composite/isyfact`" können die JSF-Komponenten der IsyFact-Web Bibliothek in die Anwendung eingebunden werden.

Komponenten stellen im Grundsatz folgendes sicher:

* JavaScript Kompatiblität: Komponenten bieten eine Fallback-Lösung an, falls kein JavaScript aktiviert ist.
* Druckfunktion Kompatibilität: Komponenten stellen eine Druckansicht zur Verfügung, falls die Druckansicht aktiviert wurde.
* Validierung: Die speziellen Formularkomponenten stellen Validierungsfunktionen zur Verfügung, sodass bei Validierungsfehlern automatisch Nachrichten und Tooltips (inkl.
Abwärtskompatibilität falls kein JavaScript aktiviert wurde) gerendert werden.

Abweichungen zu diesen Vorgaben können im Spezialfall möglich sein.

==== Button

Ein einfacher Button wird über das Tag `<isy:button>` eingebunden.

Folgende Parameter sind zulässig:

* action: Die auszuführende Aktion.
* styleClass: Die zu ergänzenden Style-Klassen.
* value: Das Label des Buttons.
* disabled: Ob der Button deaktivert ist oder nicht.
* ajax: AJAX: Ob die Aktion per AJAX ausgeführt werden soll oder nicht (seit 3.1.x)
* execute: AJAX: Welches Form ausgeführt werden soll.
* render: AJAX: Welche Elemente gerendert werden sollen.
* block: AJAX: Ob ein Klick die GUI blockieren soll bis das Ergebnis eingetroffen ist.
* showPrintView: Ein spezifisches Flag zur Erkennung der Druckansicht, falls notwendig (seit 3.1.x).
* defaultAction: Ob der Button der Default-Button sein soll. (seit 4.0.x)
* globalConfig: Eine spezifische globale Konfiguration, falls notwendig


Wenn JavaScript aktiviert ist, dann wird die AJAX-Action durchgeführt.
Andernfalls wird immer ein Full-Page-Reload durchgeführt.
Mehrere Buttons

Mehrere Buttons können in einer Zeile gruppiert werden, indem sie in das Tag `<isy:buttonRow>` eingeschlossen werden.

Folgende Parameter sind für das Tag <isy:buttonRow> zulässig:

* alignRight: Ob die Button Row eine Alignment nach Rechts besitzen soll oder nicht. Standard: false
* alignLeft: Ob die Button Row ein Alignment nach Links besitzen soll oder nicht. Standard: false Mehrere Aktionen

(Seit 3.1.x) In bestimmten Fällen kann es notwendig sein mehrere Formulare an den Server zu senden, um bestimmte Aktionen auszuführen (z.B. das Formular für den Inhaltsbereich soll auch beim Klick auf Drucken in der Seitentoolbar übermittelt werden). Dies kann durch verwenden des Tags `<isy:buttonInjectPost>` erreicht werden.
Dadurch lässt sich eine andere Aktion vor der eigentlichen Aktion des Buttons innerhalb des Tags ausführen.

Folgende Parameter sind zulässig:

* postButton: Enthält die ID des Buttons, der die zusätzliche POST-Aktion durchführen soll.
* continueAfterPost: Über diesen Wert true/false kann gesteuert werden, ob nach der POST-Aktion auch tatsächlich der eigentliche Button geklickt werden soll (z.B. um Fehlerfälle abzufangen).

==== Toolbar Button

Ein Toolbar Button wird über das Tag `<isy:buttonToolbar>` eingebunden.

Folgende Parameter sind zulässig:

* action: Die auszuführende Aktion.
* value: Das Label des Buttons. Standard: leer
* disabled: Ob der Button deaktiviert sein soll oder nicht.
Standard: false
* icon: Das Icon aus der Icon-Bibliothek (ohne Präfix 'icon-'). Standard: placeholder
* showIcon: Ob ein Icon angezeigt werden soll oder nicht. Standard: true
* reverseIconPosition: Ob das Icon rechts angezeigt werden soll. Standard: false.
* execute: AJAX: Welches Felder ausgewertet werden sollen. Standard: @form
* render: AJAX: Welcher Teilbereich aktualisiert werden soll. Standard: @form
* globalConfig: Eine spezifische globale Konfiguration, falls nötig


Wenn JavaScript aktiviert ist, dann wird die AJAX-Action durchgeführt.
Andernfalls wird immer ein Full-Page-Reload durchgeführt.
Folgende Action-Sources werden bereitgestellt:

* buttonActionEvent: Das Action Event für den Button.

===== Menü Button

Derzeit noch nicht realisiert.

[[toggle-button]]
===== Toggle Button

(Seit 3.1.x) Ein Toggle-Button wird über das Tag `<isy:buttonToggle>` eingebunden.

Folgende Parameter sind zulässig:

* action: Die auszuführende Aktion.

* value: Das Label des Buttons.

* icon: Das Icon aus der Icon-Bibliothek (ohne Präfix 'icon-').

* showIcon: Ob das Icon angezeigt werden soll oder nicht.
Standard: true

* disabled: Ob der Button deaktivert ist oder nicht.

* reverseIconPosition: Ob das Icon rechts angezeigt werden soll.
Standard: false

* active: Ob der Button ausgewählt sein soll, also aktiv ist.
Standard: false

* execute: AJAX: Welches Form ausgeführt werden soll.

* render: AJAX: Welche Elemente gerendert werden sollen.

* showPrintView: Ein spezifisches Flag zur Erkennung der Druckansicht, falls notwendig.

* globalConfig: Eine spezifische globale Konfiguration, falls notwendig.


Folgende Action-Sources werden bereitgestellt:


* toggleButton: Das Action Event für den Button.

[[icon-button]]
===== Icon Button

Ein Button mit Icon wird über das Tag `<isy:buttonIcon>` eingebunden.

Folgende Parameter sind zulässig:

* action: Die auszuführende Aktion.
* value: Das Label des Buttons. Standard: leer
* disabled: Ob der Button deaktivert ist oder nicht. Standard: false
* size: Die Größe des Icons. Mögliche Werte: small/large. Standard: large
* icon: Der Suffix des zu verwendenden Icons. Standard: placeholder
* showIcon: Ob das Icon angezeigt werden soll oder nicht. Standard: true
* tooltip: Browser-Tooltip, der über dem Icon angezeigt werden soll.
* execute: AJAX: Welches Form ausgeführt werden soll. Standard: @form.
* render: AJAX: Welche Elemente gerendert werden sollen. Standard: @form.
* globalConfig: Eine spezifische globale Konfiguration, falls notwendig.

Folgende Action-Sources werden bereitgestellt:

* buttonActionEvent: Das Action Event für den Button.

Wenn JavaScript aktiviert ist, dann wird die AJAX-Action durchgeführt.
Andernfalls wird immer ein Full-Page-Reload durchgeführt.

[[hyperlink-ueberschrift]]
===== Hyperlink

Hyperlinks sind verlinkte Texte (oder auch Grafiken), die im Wesentlichen als Navigations-Mechanismus dienen – so z.B. um andere Inhalte wie Fenster zu öffnen.
Ebenso können Hyperlinks dazu eingesetzt werden, Funktionen aufzurufen.

Links können mit dem Standard-HTML Tag <a...> oder durch Nutzung des JSF Tags <h:outputLink/> erzeugt werden.

_Hinweis:_ Auch die Nutzung des JSF Tags können <h:commandLink /> ist möglich.
Jedoch ist die Funktionalität nur bei aktiviertem JavaScript nutzbar.
Entsprechende Fallbackmaßnahmen müssen also getroffen werden.

(Seit 3.1.x) Falls ein Hyperlink Aktionen im Webflow, bzw.
JSF Ausführen soll, so kann das Tag `<isy:hyperlink>` verwendet werden.
Dieses Tag stellt sicher, dass falls JavaScript deaktiviert ist, ein Button mit Layout eines Links dargestellt wird.

Das Tag hat folgende Parameter:

* action: Die Action, die ausgeführt werden soll.
* value: Das Label des Links.

* title: Der Alternativtext.

* baseStyleClass: Die Basistyleklasse zum Überschreiben.

* additionalStyleClass: Zusätzliche Styleklassen.

* openInNewTab: Ob der Link in einem neuen Tab geöffnet werden soll.
Funktioniert nur mit aktiviertem JavaScript.


Das Tag stellt folgende ActionSource bereit:

* hyperlink: Die ActionSource des Links.

[[label-ueberschrift]]
===== Label

Ein Label besteht in der Regel aus einem Text.
In manchen Fällen kann es auch eine Kombination aus einem Icon und einem Text sein (z.B. Buttons mit Icon und Text). Es gibt auch Bedienelemente deren Label ausschließlich aus einem Icon bestehen.

Für reine Labels existieren keine spezifischen JSF-Komponenten.
Das Standard-JSF Tag <h:outputText/> kann verwendet werden.

Für formularbasierte Masken werden automatisch Labels für Eingabefelder erzeugt.
Siehe auch Formulareingabefelder.

(Seit 3.1.x) Für das Ausgeben eines Textes (mit zugehörigem Label) in einem Formular kann das Tag `<isy:formLabel>` verwendet werden.

Es besitzt folgende Parameter:

* reference: Die Referenz des Objekts für die Validierung

* value: Der Text für das Ausgabelabel.

* label: Der Text für das Label.

* labelStyleClass: Die CSS-Klasse für das Label.
Standard: col-lg-6

* inputStyleClass: Die CSS-Klasse für den Ausgabebereich.
Standard: col-lg-6

* textStyleClass: Die CSS-Klasse für den auszugebenden Text.

* tooltip: Der Tooltip für das Ausgabelabel.

* breakWords: Erlaubt das Deaktivieren des Wrappings von Text innerhalb der Komponente.

* converter: Die JSF-Converter-ID, welche die Ausgabe in einen Text konvertiert.

* globalConfig: Eine spezifische globale Konfiguration, falls benötigt.

[[eingabefelder-ueberschrift]]
==== Eingabefelder

Ein Eingabefeld dient der Eingabe von Text durch den Benutzer.
Ein Eingabefeld ist in der Regel einzeilig.

Für einzelne Eingabefelder existieren derzeit noch keine einfachen Komponenten.
Um ein einfaches Eingabefeld einzufügen kann das JSF-Tag `< h:inputText/>` mit den Bootstrap-Klassen form-control verwendet werden.
Für formularbasierte Eingaben existiert das Tag `<isy:formInput/>`, welches ein Eingabefeld in einem Formularlayout mit Label kapselt.
Nähere Informationen hierzu finden sich im Formularkapitel.

Folgende Parameter sind zulässig:

* reference: Die Referenz des Objekts

* value: Der Wert für das Databinding im Eingabefeld

* required: Ob die Eingabe ein Pflichteingabe ist

* readonly: Ob die Darstellung nur lesend erfolgen soll

* label: Der Text für das Label

* labelStyleClass: Die CSS-Klasse für das Label

* inputStyleClass: Die CSS-Klasse für den Eingabebereich.

* placeholder: Der Platzhalter, welcher im Eingabefeld angezeigt wird

* inputmask: Die Eingabemaske

* inputmaskInsertMode: Die Eingabemaske: ob text soll überschrieben werden beim eintippen

* maxlength: Die maximale Länge der Eingabe

* width: Die maximale Breite des Eingabefeldes.

* showPrintView: Zur aktuellen Druckansicht-Anzeige aus dem BasisModel

* tooltip: Tooltip.

* validationModel: Ein spezifisches Validation-Model, falls benötigt.

* globalConfig: Eine spezifsche globale Konfiguration, falls benötigt.

* charpicker: Die Referenz des Objekts.

* contentRight: Der Inhalt der rechts vom Listpicker angezeigt wird

* type: Der Typ des Eingabefelds, so dass diese Komponente z.B. auch für Passwort-Felder verwendet werden kann.
Mögliche Werte alle Werte für das Feld type des HTML Input Felds
* fourEyesMode: 4 Augen Prinzip Mode (locked, unlock)

* fourEyesLastValue: 4 Augen Prinzip Mode (locked, unlock)


[[aktionseingabefeld]]
===== Aktionseingabefeld

Die Implementierung erfolgt über das Tag `<isy:actionInput>` bzw. `<isy:formActionInput>`. 

:desc-image-aktionseingabefeld: Aktionseingabefeld
[id="image-aktionseingabefeld",reftext="{figure-caption} {counter:figures}"]
.{desc-image-aktionseingabefeld}
image::image155.png[align="center", width="685",height="25"]

Folgende Parameter sind für `<isy:action Input>` zulässig:

* reference: Die Referenz des Objekts.
* value: Der anzuzeigende Wert als `String`.

* placeholder: Der Platzhalter, welcher im Eingabefeld angezeigt wird.

* action: Die auszulösende Aktion, beim Klicken aufs Icon. Wird ignoriert im Falle von `mode = input-only`.

* icon: Das benutzte Icon aus dieser
https://getbootstrap.com/docs/3.3/components/[Glyph-Icons-Liste]
, nur der Suffix, z.B. `search.`

* iconColor: Die Farbe des Icons, per Default `#45484D`.

* mode: Eins aus `normal` für Inputfeld und Icon aktiv, `button-only` für nur Icon aktiv und `input-only` für nur Inputfeld aktiv.

* tooltip: Einen optionalen Tooltip für das Icon.

* disabled: Ob das Inputfeld deaktiviert ist oder nicht.

* fourEyesMode: 4 Augen Prinzip Mode (locked, unlock).

* fourEyesLastValue: 

* inputStyleClass: Die zu ergänzenden Style-Klassen.


Folgende Parameter sind zusätzlich zu den eben genannten für `<isy:formActionInput>` zulässig:

* required: Ob die Eingabe ein Pflichteingabe ist.

* label: Der Text für das Label.

* labelStyleClass: Die CSS-Klasse für das Label.

* maxlength: Die maximale Länge der Eingabe.

* validationModel: Ein spezifisches Validation-Model, falls benötigt.

* globalConfig: Eine spezifsche globale Konfiguration, falls benötigt.

[[eingabefelder-fuer-geldbetraege]]
===== Eingabefeld für Geldbeträge



Die Implementierung erfolgt über das Tag `<isy:formCurrencyInput>`. Folgende Parameter sind zulässig:

* reference: Die Referenz des Objekts.

* value: Der Wert für das Databinding im Eingabefeld.

* required: Ob die Eingabe ein Pflichteingabe ist.

* readonly: Ob die Darstellung nur lesend erfolgen soll.

* label: Der Text für das Label.

* labelStyleClass: Die CSS-Klasse für das Label.

* inputStyleClass: Die CSS-Klasse für den Eingabebereich.

* placeholder: Der Platzhalter, welcher im Eingabefeld angezeigt wird.

* maxlength: Die maximale Länge der Eingabe.

* validationModel: Ein spezifisches Validation-Model, falls benötigt.

* globalConfig: Eine spezifsche globale Konfiguration, falls benötigt.

* onblur: onblur JavaScript-Funktion wird aufgerufen, wenn der Cursor das Feld verlässt.

* onkeyup: onkeyup JavaScript-Funktion wird aufgerufen, wenn eine Tastatureingabe in dem Feld gemacht wurde.

* fourEyesMode: 4 Augen Prinzip Mode (locked, unlock).

* fourEyesLastValue:

* alignright: Ob der Text innerhalb des Eingabefeldes rechts ausgerichtet sein soll. Default ist false.



Im Vergleich zu `<isy:formInput>` nimmt diese Komponente nur die Eingabe von Zahlen und Kommas entgegen.

Beim Verlassen des Feldes Wird die eingegebene Zahl in eine Zahl mit zwei Nachkommastellen umgewandelt.

*Zustände*

Wie bei `<isy:formInput>`.




[[upload]]
===== Upload

kein Implementierungshinweis


[[text-box]]
===== Text Box

Eine Textbox kann über das HTML `<textarea>` mit Bootstrap Klasse `form-control` eingebunden werden.

Text Boxen sehen optisch aus wie Eingabefelder, es können jedoch mehrzeilige Daten eingegeben werden.

:desc-image-bildtextbox: Text Box
[id="image-bildtextbox",reftext="{figure-caption} {counter:figures}"]
.{desc-image-bildtextbox}
image::image163.png[align="center", width="358",height="111"]

(Seit 3.1.x) Für Formulare kann das Tag `<isy:formTextarea>` verwendet werden.
Folgende Parameter sind zulässig:

* reference: Die Referenz des Objekts für die Validierung
* value: Der Wert für das Databinding im Eingabefeld
* required: Ob die Eingabe ein Pflichteingabe ist. Standard: false
* disabled: Ob die Komponente aktiviert ist oder nicht. Standard: false
* readonly: Ob nur lesend auf das Feld zugegriffen werden kann. Standard: false
* label: Der Text für das Label.
* labelStyleClass: Die CSS-Klasse für das Label. Standard: col-lg-6
* inputStyleClass: Die CSS-Klasse für den Eingabebereich. Standard: col-lg-6
* textareaStyleClass: Die CSS-Klasse für die Textarea.
* tooltip: Der anzuzeigende Tooltip
* rows: Die Anzahl an Zeilen.
* cols: Die Anzahl an Spalten.
* maxlength: Die maximal Anzahl von Zeichen
* showPrintview: Ein spezifisches Flag zur Erkennung der Druckansicht, falls notwendig.
* validationModel: Ein spezifisches Validation-Model, falls benötigt
* globalConfig: Eine spezifische globale Konfiguration, falls benötigt

[[dropdown-menue]]
==== Dropdown Menü

Mit einem Dropdown Menü kann der Benutzer per Mausklick oder Tastatur-Bedienung genau einen Wert aus einer Liste von Optionen auswählen.

:desc-image-bildddropdownmenue: Dropdown Menü
[id="image-bildddropdownmenue",reftext="{figure-caption} {counter:figures}"]
.{desc-image-bildddropdownmenue}
image::image166.png[align="center", width="627",height="156"]

Ein Dropdown Menü wird über das Tag `<isy:selectOneDropdown>` eingebunden.
Für Formulareingaben existiert das Tag `<isy:formSelectOneDropdown>`.

Folgende Parameter sind zulässig:

* reference: Die Referenz des Objekts

* referenceId: Der Wert der id

* value: Der Wert der Auswahl für das Databinding

* invalid: Ob die Auswahl invalide ist oder nicht 

* disabled: Ob die Auswahl deaktiviert ist oder nicht

* title: Das Tooltip über dem SelectOneDropdown

* globalConfig: Eine spezifische globale Konfiguration, falls notwendig.

* dropdownStyleClass: Die CSS-Klasse für das Dropdownmenü

* readonly: Ob die Darstellung nur lesend erfolgen soll

* disabled: Ob die Auswahl deaktiviert ist oder nicht

* fourEyesMode: 4 Augen Prinzip Mode (locked, unlock)

* fourEyesLastValue: 4 Augen Prinzip Mode (locked, unlock)

* valueChangeListener: Die Methode, die bei einem ValueChange aufgerufen

* converter: Konverter-Bean für die angezeigten Elemente

* converterAttribute: Parameter für den Konverter


Für die Komponente formSelectOneDropdown gibt es zusätzlich die folgenden Paramter:

* label: Der Text für das Label

* labelStyleClass: Die CSS-Klasse für das Label

* inputStyleClass: Die CSS-Klasse für den Eingabebereich.
* validationModel: Ein spezifisches Validation-Model, falls benötigt.
* globalConfig: Eine spezifsche globale Konfiguration, falls benötigt.

Je nach JavaScript Aktivierung wird das Dropdown Menü über ein Bootstrap-Plugin (JavaScript aktiviert) oder als natives Element (JavaScript deaktiviert) dargestellt.

===== Tabs

Tabs dienen der Informationsstrukturierung und Reduktion der Anzahl gleichzeitig sichtbarer Inhaltsbereiche, wenn die Informationen schnell innerhalb des gleichen Fensters zugreifbar sein müssen.
Tabreiter verhalten sich entsprechend dem analogen Vorbild eines Karteireiters, der dazu dient, verschiedene Karteikarten voneinander zu trennen.
Tabs werden häufig dazu verwendet, um Eigenschaften eines Objekts in inhaltliche sinnvolle Gruppen aufzuteilen.

:desc-image-bildtabs: Tabs
[id="image-bildtabs",reftext="{figure-caption} {counter:figures}"]
.{desc-image-bildtabs}
image::image173.png[align="center", width="626",height="35"]

Tabs werden über die Tags `<isy:tabGroup>`, `<isy:tabHeader>` und `<isy:tabContent>` eingebunden.
Im Folgenden ein Beispiel:

:desc-listing-tabgroup: Beispiel für tabGroup, tabHeader, tabContent
[id="listing-tabgroup",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-tabgroup}
[source, xml]
----
<isy:tabGroup tabGroupId="testTab" globalTabContentRefs="A P S"
   globalTab="A" defaultTab="A"
   tabGroupModel="#\{jsfSteuerelementeModel.tabGroupModel}">

   <f:facet name="tabHeader">
      <isy:tabHeader value="Auskunft" name="A" />
      <isy:tabHeader value="Personalien" name="P" />
      <isy:tabHeader value="Sachverhalte" name="S" />

   </f:facet>
      <isy:tabContent name="A">Dies ist die Auskunft </isy:tabContent>
      <isy:tabContent name="P">Dies sind Personalien </isy:tabContent>
      <isy:tabContent name="S">Dies sind die Sachverhalte </isy:tabContent>

</isy:tabGroup>
----

Zunächst wird die Tabgruppe mit dem Tag `<isy:tabGroup>` allgemein definiert. Folgende Parameter sind zulässig:

* tabGroupModel: Das Model für die Tabgruppe. Sollte im Maskenmodel liegen.
* defaultTab: Der Name des Default-Tabs. Der Default-Tab ist beim initialen Öffnen aktiv.
* globalTab: Der Name des globalen Tabs.
* globalTabContentRefs: Die Liste an Namen der Tabs, welche beim Anzeigen des globalen Tabs auch angezeigt werden sollen.
* execute: AJAX: Welches Form ausgeführt werden soll. Standard: @form.
* render: AJAX: Welche Elemente gerendert werden sollen. Standard: @form.
* globalConfig: Eine spezifische globale Konfiguration, falls notwendig.


Wenn JavaScript aktiviert ist, dann wird die AJAX-Action durchgeführt.
Andernfalls wird beim Wechsel der Tabs ein Full-Page-Reload durchgeführt.

Einzelne Tabheader werden mit dem Tag `<isy:tabHeader>` definiert. Folgende Parameter sind zulässig:

* name: Der Name des Tabs, für welchen dieser Header definiert ist.
* value: Der Titel des Tabs zur Anzeige.
* globalConfig: Eine spezifische globale Konfiguration, falls notwendig.
* skipAction: Ob die übergebene action ausgelassen werden soll.
Default ist false, die action wird standardmäßig also ausgeführt. (seit 4.0.x)
* action: Die action kann überschrieben werden, um z.B. den aktuellen Reiter validieren zu können. (seit 4.0.x)

Inhalte von Tabs werden mit dem Tag `<isy:tabContent>` definiert. Folgende Parameter sind zulässig:

* name: Der Name des Tabs, zu welchem dieser Inhalt gehört.
* globalConfig: Eine spezifische globale Konfiguration, falls notwendig.
* preload: Ob das Tab im JS-Fall vorgeladen werden soll.
Default ist false, so dass nicht vorgeladen wird.

Erläuterung zu den Attributen preload und skipAction:

* Zwischen den beiden Attributen besteht eine Abhängigkeit.
Sie müssen immer den gleichen Wert aufweisen, ansonsten funktioniert der Tab nicht korrekt.
* Das Attribut preload legt fest, ob der Inhalt des Tabs beim Laden der gesamten Seite vorgeladen werden soll.
Bei einem Wechsel zwischen vorgeladenen Tabs muss dann entsprechend kein Server-Aufruf stattfinden.
In diesem Fall darf aber die action des tabHeader nicht ausgeführt werden, weil sonst doch ein Server-Aufruff stattfinden würde.
Dies würde sowohl unnötigen Netzwerkverkehr -, als auch unerwünschtes Verhalten bei der Tab-Auswahl hervorrufen.
* Standardmäßig stehen beide Werte auf false.
Wenn das Vorladen gewünscht ist, müssen beide Werte explizit auf true gesetzt werden.


[[taboverflow-menue]]
===== Taboverflow Menü

Das Taboverflow Menü dient zur Vermeidung mehrzeiliger Tabreiter-Elemente.
Das Menü enthält alle Tabs, die nicht direkt auf dem Screen angezeigt werden können.


*Hinweise zur Implementierung*

Diese Konzept wurde noch nicht realisiert.

[[liste-ueberschrift]]
==== Liste

Listen werden benutzt, um eine überschaubare Anzahl an Daten oder Objekten eines Typus übersichtlich und vergleichbar darzustellen.

:desc-image-listemitlistenkopf: Liste mit Listenkopf
[id="image-listemitlistenkopf",reftext="{figure-caption} {counter:figures}"]
.{desc-image-listemitlistenkopf}
image::image178.png[align="center", width="305",height="326"]

(seit 4.0.x) Eine Liste mit Einfachauswahl wird mit dem Tag `<isy:formSelectOneList>` eingebunden.

Folgende Parameter sind zulässig:


* reference: Die Referenz des Objekts.

* value: Der Wert der Auswahl für das Databinding.

* disabled: Ob die Liste deaktiviert ist.

* size: Dieses Attribut wird im Sinne von bootstrap-selectlist.js interpretiert, d.h. es gibt die Anzahl der Zeilen die sichtbar sind an.

* checkboxed: Falls true werden zusätzlich zum highlighting, auch checkboxes angezeigt.

* required: Ob die Eingabe ein Pflichteingabe ist.

* label: Der Text für das Label.

* labelStyleClass: Die CSS-Klasse für das Label.

* inputStyleClass: Die CSS-Klasse für den Eingabebereich.

* validationModel: Ein spezifisches Validation-Model, falls benötigt.

* globalConfig: Eine spezifsche globale Konfiguration, falls benötigt.


(seit 4.0.x) Eine Liste mit Mehrfachauswahl wird mit dem Tag `<isy:formSelectManyList>` eingebunden.

Folgende Parameter sind zulässig:


* reference: Die Referenz des Objekts.

* value: Der Wert der Auswahl für das Databinding.

* disabled: Ob die Liste deaktiviert ist.

* size: Dieses Attribut wird im Sinne von bootstrap-selectlist.js interpretiert, d.h. es gibt die Anzahl der Zeilen die sichtbar sind an.

* checkboxed: Falls true werden zusätzlich zum highlighting, auch checkboxes angezeigt.

* required: Ob die Eingabe ein Pflichteingabe ist.

* label: Der Text für das Label.

* labelStyleClass: Die CSS-Klasse für das Label.

* inputStyleClass: Die CSS-Klasse für den Eingabebereich.

* validationModel: Ein spezifisches Validation-Model, falls benötigt.

* globalConfig: Eine spezifsche globale Konfiguration, falls benötigt.

[[tabelle-ueberschrift]]
==== Tabelle

Eine Tabelle dient der übersichtlichen Anzeige von größeren Datenmengen.
Die Tabelle besteht aus mehreren Informationsspalten, die zur Sortierung verwendet werden können.

:desc-image-einfuehrungeinertabelle: Tabelle
[id="image-einfuehrungeinertabelle",reftext="{figure-caption} {counter:figures}"]
.{desc-image-einfuehrungeinertabelle}
image::image180.png[align="center", width="687",height="243"]

:desc-image-interaktivezeilen: Tabelle – Zustände interaktiver Zeilen
[id="image-interaktivezeilen",reftext="{figure-caption} {counter:figures}"]
.{desc-image-interaktivezeilen}
image::image181.png[align="center", width="687",height="93"]

Die Umsetzung der Tabelle unterscheidet sich grundsätzlich zur Widgets wie der von JSF bereitgestellten <h:dataTable>. Die `<isy:dataTable>` ist näher am Layout einer eigentlichen Tabelle aufgebaut und dadurch flexibler nutzbar (z.B. dynamische Anzahl an Spalten). Dafür jedoch auch eine größere Konfiguration möglich.

Es existieren folgende Tags zur Konfiguration der `<isy:dataTable>`:


* <isy:dataTable>
* <isy:dataTableHeader>
* <isy:dataTableRowAllSelection>
* <isy:dataTableRows>
* <isy:dataTableCell>
* <isy:dataTableDetailButton>
* <isy:dataTableRowSelection>


Beispiel für die Definition einer `<isy:dataTable>`:

:desc-listing-dataTable: Beispiel für dataTable
[id="listing-dataTable",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-dataTable}
[source, xml]
----
<isy:dataTable dataTableModel="#\{...}"
    dataTableController="#\{...}"
    action="trefferlisteDoppelklick">
  <f:facet name="tableToolbar">

    <isy:buttonGroup>
       <isy:buttonToolbar .../>
    </isy:buttonGroup>
  </f:facet>

   <f:facet name="tableHeader">
      <isy:dataTableHeader name="Vorname" />
      <isy:dataTableHeader name="Nachname" />
      <isy:dataTableHeader name="Aktionen" />
   </f:facet>
   <isy:dataTableRows
      rowDefinition="/WEB-INF/gui/.../rowDefinition.xhtml"
      detailDefinition="/WEB-INF/gui/.../detailDefinition.xhtml" />

</isy:dataTable>
----
Die grundlegende Basis bildet das `<isy:dataTable>` Tag.
Folgende Parameter sind zulässig:


* dataTableModel: Das zugehörige, spezifische DataTableModel.
Das Model muss Teil des Maskenmodels sein.
Das Model enthält eine Liste an DataTableItems (die konkreten Datensätze).

* dataTableController: Der zugehörige, spezifische DataTableController. Der Controller stellt z,B. Suchfunktionalität bereit.

* selectable: Ob die Datatable selektierbar ist oder nicht. Standard: false.

* selectionMode: Der Selektionsmodus der Zeilen (single/multiple). Standard: multiple.

* action: Die Aktion, welche beim Doppelklick auf eine Zeile ausgeführt wird.

* execute: AJAX: Das Form, welches beim Doppelklick ausgeführt werden soll. Standard: @form.

* render: AJAX: Das Form, welches beim Doppelklick gerendert werden soll. Standard: @form.

* globalConfig: Die spezifische globale Konfiguration, falls notwendig.


In der JSF-Facet tableToolbar werden Listen von `<isy:buttonGroup>` Tags erwartet.
Die Listen können jeweils Elemente der Typen `<isy:buttonToolbar>` (Button in der Toolbar, siehe Toolbar Button) und `<isy:buttonToggle>` (Toggle-Button in der Toolbar der Tabelle) enthalten. Folgende Parameter sind für das Tag `<isy:buttonToggle>` zulässig:


* action: Die auszuführende Aktion.
* value: Das Label des Buttons. Standard: leer
* icon: Das Icon aus der Icon-Bibliothek (ohne Präfix 'icon-'). Standard: placeholder
* showIcon: Ob ein Icon angezeigt werden soll oder nicht. Standard: true
* reverseIconPosition: Ob das Icon rechts angezeigt werden soll. Standard: false.
* disabled: Ob der Button deaktiviert sein soll oder nicht. Standard: false
* execute: AJAX: Welches Felder ausgewertet werden sollen. Standard: @form
* render: AJAX: Welcher Teilbereich aktualisiert werden soll. Standard: @form
* globalConfig: Eine spezifische globale Konfiguration, falls nötig


In der JSF-Facet tableHeader wird eine Liste von `<isy:dataTableHeader>` Tags erwartet.
Ein Tag entspricht dabei einem Titel einer Spalte.
Folgende Parameter sind zulässig:

* name: Der Header-Name / Spaltenüberschrift.
* sortable: Ob der Header sortierbar ist oder nicht.
Standard: false.
* sortAttribute: Das zugehörige Sortierattribut, falls der Header sortierbar ist.
_*(Für plis-web Versionen kleiner als 4.0)*_
* sortProperty: Das zugehörige Sortierattribut, falls der Header sortierbar ist.
_*(Ab plis-web 4.0)*_
* width: Die Breite der Spalte.


Die Zeilen der Datentabelle werden mit dem Tag `<isy:dataTableRows>` definiert. Folgende Parameter sind zulässig:

* rowDefinition: Pfad zur XHTML-Seite für Zeilen
* detailDefinition: Pfad zur XHTML-Seite für die Detailansicht


Beispiel einer Row-Definition:

:desc-listing-rowdefinition: Beispiel einer Row-Definition
[id="listing-rowdefinition",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-rowdefinition}
[source, xml]
----
<ui:composition ...
   <isy:dataTableCell> #\{dataTableItem.vorname}</isy:dataTableCell>
   <isy:dataTableCell> #\{dataTableItem.nachname}</isy:dataTableCell>
   <isy:dataTableCell>
      <isy:dataTableDetailButton
           dataTableModel="#\{...}"
           dataTableController="#\{...}" />
       _*(Für plis-web Versionen kleiner als 4.0)*_
      <isy:dataTableDetailButton/>
       _*(Ab plis-web 4.0)*_
    </isy:dataTableCell>

</ui:composition>
----

Die Row-Definition wird für jeden Datensatz in der Tabelle eingebunden.
Der UI-Parameter dataTableItem weist immer auf den aktuellen Treffer (also eine Objekt mit der Schnittstel DataTableItem). Mit diesem Parameter können dann für jede Spalte die `<isy:dataTableCell>` Tags eingebunden werden.
Die Inhalte dieser Tags repräsentieren den Inhalt der Tabellenzelle für diese Treffer.
Die Reihenfolge der Spalten werden durch die Headerdefinition festgelegt.
Das Tag `<isy:dataTableCell>` hat derzeit folgende Parameter:


* hidden: Ob die Spalte angezeigt werden soll oder nicht.
Standard: true.

Die Einbindung der Row-Definition erfolgt mittels dem JSF Tag `<ui:repeat>`. Als Statusvariable wird dataTableItemRepeatStatus verwendet.
Auch auf diese Variable kann innerhalb der Row-Definition zugegriffen werden.

Zur Vereinfachung des Aufrufs der Detailansicht, wird das Tag `<isy:dataTableDetailButton>` angeboten.
Dieses Tag rendert einen Button und öffnet die Detailansicht eines Treffers.
Die Detailansicht eines Treffers befindet sich an der im Tag `<isy:dataTableRows>` angegebenen Stelle.

Beispiel einer Detail-Definition:

:desc-listing-detaildefinition: Beispiel einer Detail-Definition
[id="listing-detaildefinition",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-detaildefinition}
[source, xml]
----
<ui:composition ...
   <td colspan="2">
     <div class="form-horizontal readonly">
      <div class="row row-df">
        <div class="col col-lg-6">
          <isy:formLabel reference="aktenzeichen"
             value="#\{dataTableItem.aktenzeichen}"
             label="#\{msg_currentflow.MEL_Trefferliste_Aktenzeichen}"/>
          <isy:formLabel reference="ordnungsnummer"
             value="#\{dataTableItem.ordnungsnummer}"
             label="#\{msg_currentflow.MEL_Trefferliste_Ordnungsnummer}"/>
          <isy:formLabel reference="speicherungsdatum"
             value="#\{dataTableItem.speicherungsdatum}"
             label="#\{msg_currentflow.MEL_Trefferliste_Speicherungsdatum}"/>
        </div>
      </div>
     </div>
   </td>
</ui:composition>
----

Die Detail-Definition enthält beliebigen Inhalt.
Im Beispiel ist dies ein Formular mit der Ausgabe von drei Labeln in der linken Hälfte der Tabelle.
Analog zur Row-Definition kann auf den aktuellen Treffer über die UI-Parameter dataTableItem udn dataTableItemRepeatStatus zugegriffen werden.

Details beispielsweise zur Sortierung oder des Selektionsverhaltens finden sich in den Unterkapiteln dieses Abschnitts.

*Migration von auf plis-web 4.0*

Mit plis-web Version wurde die Tabellenkomponente mit den Funktionen Paginierung, Filterung und Sortierung erweitert.
Die neue Implementierung ist nur bedingt kompatibel.
Folgende Schritte sind für die Migration notwendig.

*In der View:*

DataTable

* jsSortFunction: _entfällt._
* sortAttributeConverterId. _entfällt_

DataTableDetailButton

* dataTableMdel: _entfällt, wird nun automatisch ermittelt._
* dataTableController: _entfällt, wird nun automatisch ermittelt._

DataTableHeader

* sortAttribute: _entfällt, da nun sortProperty verwendet wird._
* sortProperty: __neu__, ersetzt das Attribut sortAttribute und ist nun ein String-Wert


DataTableRowAllSelection

* globalConfig: _entällt, wird nun automatisch ermittel._


**In der Java Implementierung**:

DataTableModel

* model.setSortDirection(sortDirection) : _entfällt, wurde in die Klasse SortModel verschoben._
* model.getSortModel().setDirection(direction): _neu, ersetzt_ setSortDirection
* model.setSortAttribute(sortAttribute): _entfällt, wird in der Klasse SortModel durch die Methode setProperty ersetzt._
* model.getSortModel().setProperty(property) : _neu, ersetzt setSortAttribute._

DataTableController

* readItems: _muss überschrieben werden._
* getItemById: _muss überschrieben werden_
* updateDisplayItems: _muss überschrieben werden.
Aus Kompatibilitätsgründen wird hier search und sortInvoked aufgerufen._
* sortInvoked: _entfällt / deprecated, aus Kompatibitätsgründen noch vorhanden._
* search: _entfällt / deprecated, aus Kompatibitätsgründen noch vorhanden._
* DataTableItem Typ muss als Parameter angegeben werden.

[[sortierung-tabelle]]
===== Sortierung in einer Tabelle

Die `<isy:dataTable>` bietet Möglichkeiten zur Sortierung an.
Dazu müssen die einzelnen Spalten-Header über das `<isy:dataTableHeader>` Tag entsprechend konfiguriert werden.

:desc-image-tabellesortierungimkopf: Tabelle – Sortierungs-Indikator in Tabellenkopf
[id="image-tabellesortierungimkopf",reftext="{figure-caption} {counter:figures}"]
.{desc-image-tabellesortierungimkopf}
image::image183.png[align="center", width="627",height="137"]

*plis-web kleiner als 4.0*

Beispiel:

:desc-listing-dataTableHeader: Beispiel für dataTableHeader
[id="listing-dataTableHeader",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-dataTableHeader}
[source, xml]
----
<isy:dataTableHeader
   name="#\{msg_currentflow.MEL_Trefferliste_Vorname}"
   sortable="true"
   sortAttribute="#\{enumJsfConstants.NUMMERNSUCHE_SORTATTRIBUTE_VORNAME}" />
----

Durch Angabe von sortable=true werden automatisch Buttons und Symbole zur Sortierung hinzugefügt.
Bei Klick auf den Suchbutton wird im DataTableModel das SortAttribute festgehalten und im spezifischen Trefferlistencontroller die Methode sortInvoked(...) aufgerufen.
Je nach Anwendungsfall kann die Methode dann die Liste sortieren oder aber eine erneute Suche in der Datenquelle durchführen (z.B. bei paginierten Trefferlisten).

Auch die initiale Sortierung muss vom enstprechenden Trefferlistencontroller durchgeführt werden.

*Ab plis-web 4.0*

:desc-listing-dataTableHeader2: Beispiel für dataTableHeader (ab plis-web 4.)
[id="listing-dataTableHeader2",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-dataTableHeader2}
[source, xml]
----
<isy:dataTableHeader
   name="#\{msg_currentflow.MEL_Trefferliste_Vorname}"
   sortable="true" sortProperty="vorname" />
----

Durch Angabe von `sortable=true` und der dem Attribut `sortProperty` werden automatisch Buttons und Symbole zur Sortierung hinzugefügt.
Bei m Initialisieren des Models muss der Operationsmodus (SERVER oder CLIENT) angegegben werden.

`model.setMode(DatatableOperationMode.SERVER);`

Im Modus CLIENT erfolgt die Sortierung per JavaScript automatisch.
Im SERVER Modus wird die Methode updateDisplayItems des `DataTableControllers` aufgerufen, die die Tabelleneinträge unter allen Bedingungen (wie z.B. filter, sort und pagination) anzeigt.

[[selektionsverhalten-tabelle]]
===== Selektionsverhalten in einer Tabelle
:desc-image-tabellemehrfachselektion: Tabelle – Mehrfachselektion über STRG Taste & Maus
[id="image-tabellemehrfachselektion",reftext="{figure-caption} {counter:figures}"]
.{desc-image-tabellemehrfachselektion}
image::image185.png[align="center", width="629",height="200"]

:desc-image-tabellemehrfachselektioncheckbox: Tabelle – Mehrfachselektion über Checkboxen
[id="image-tabellemehrfachselektioncheckbox",reftext="{figure-caption} {counter:figures}"]
.{desc-image-tabellemehrfachselektioncheckbox}
image::image186.png[align="center", width="627",height="137"]

:desc-image-textlinkkennzeichen: Textlink z.B. Kennzeichnung eines Objektes
[id="image-textlinkkennzeichen",reftext="{figure-caption} {counter:figures}"]
.{desc-image-textlinkkennzeichen}
image::image187.png[align="center", width="629",height="207"]


Um die Selektion von Zeilen zu ermöglichen, müssen folgende Konfigurationen durchgeführt werden:

_1._ In der Header-Definition muss ein `<isy:dataTableHeader>` Tag an erster Stelle mit folgender Definition aufgenommen werden:


:desc-listing-zeilenselektion1: Zeilenselektion Schritt 1
[id="listing-zeilenselektion1",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-zeilenselektion1}
[source, xml]
----
<isy:dataTableHeader>
   <isy:dataTableRowAllSelection />
</isy:dataTableHeader>
----

_2._ In der Row-Definition muss ein `<isy:dataTableCell>` Tag an erster Stelle mit folgender Definition aufgenommen werden:


:desc-listing-zeilenselektion2: Zeilenselektion Schritt 2
[id="listing-zeilenselektion2",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-zeilenselektion2}
[source, xml]
----
<isy:dataTableCell>
   <isy:dataTableRowSelection />
</isy:dataTableCell>
----

_3._ In der Table-Definition (`<isy:dataTable>`) muss das Attribut selectable="true" gesetzt sein.
Der Selektierungsmodus (einzeln,mehrere) wird über das Attribut `selectionMode` gesteuert.


[[grosse-datenmengen-tabelle]]
===== Große Datenmengen in einer Tabelle

Tabellen können sehr viele Daten enthalten und gegebenenfalls sehr lang werden.
Um dem Benutzer den Umgang mit solchen Tabellen zu vereinfachen, werden zunächst nicht alle Daten initial in der Tabelle angezeigt. Über einen _Mehr anzeigen_ Button oder einen Paginator kann der Benutzer sich bei Bedarf mehr Daten anzeigen lassen.

:desc-image-tabelleohnepaginator: Tabelle ohne Paginator
[id="image-tabelleohnepaginator",reftext="{figure-caption} {counter:figures}"]
.{desc-image-tabelleohnepaginator}
image::image189.png[align="center", width="629",height="245"]

:desc-image-tabellemitpaginator: Tabelle mit Paginator
[id="image-tabellemitpaginator",reftext="{figure-caption} {counter:figures}"]
.{desc-image-tabellemitpaginator}
image::image189.png[align="center", width="629",height="328"]

Die Implementierung einer Paginierung erfolgt über das Facet `<f:tablePagination>`, das Tag `<t:dataTablePaginator>` und den dazugehörigen `DataTablePaginationModel`

Zum Beispiel im `DataTableController`

:desc-listing-implPaginierung: Implementierung Paginierung
[id="listing-implPaginierung",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-implPaginierung}
[source, java]
----
@Override

public void initialisiereModel(DataTableModel model) {
   model.getPaginationModel().setPageSize(3);
   model.getPaginationModel().setMode(PaginationMode.SIMPLE);
   updateDisplayItems(model);
}
----

und in der View:

:desc-listing-implPaginierungView: Implementierung Paginierung in der View
[id="listing-implPaginierungView",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-implPaginierungView}
[source, xml]
----
<f:facet name="tablePagination">
   <isy:dataTablePaginator />
</f:facet>
----

[[check-box-ueberschrift]]
==== Check Box

Eine Check Box repräsentiert eine unabhängige, nicht-exklusive Auswahl.
Der Benutzer kann beliebige Optionen auswählen.

Eine einzelne Checkbox wird über das Tag `<isy:selectBooleanCheckbox>` eingebunden.

Folgende Parameter sind zulässig:


* value: Der Wert der Checkbox für das Databinding im Model.

* label: Das Label der Checkbox.

* disabled: Ob die Checkbox deaktiviert ist oder nicht.
Standard: false

* showPrintView: Ein spezifisches Flag zur Erkennung der Druckansicht, falls notwendig (seit 3.1.x).

* required: Ob die Checkbox zwingend markiert werden muss oder nicht.
Standard: false (seit 3.1.x).

* onchange: Das onchange-Event der Checkbox (seit 3.1.x).


Mehrere Checkboxen werden über das Tag `<isy:selectManyCheckbox>` eingebunden.

Folgender Parameter ist zulässig:


* value: Der Wert für das Data-Binding (Eine Liste an SelectItems)

* showPrintView: Ein spezifisches Flag zur Erkennung der Druckansicht, falls notwendig (seit 3.1.x).


__Hinweis: __Der Tri-State ist noch nicht umgesetzt.

(Seit 3.1.x) Für Formulare existiert das Tag `<isy:formCheckbox>` und bietet vor allem eine Integration auf einem Formular.

Folgende Parameter sind zulässig:


* value: Der Wert der Checkbox für das Databinding im Model.

* reference: Die Referenz des Objekts für die Validierung.

* label: Der Text für das Label.

* labelStyleClass: Die CSS-Klasse für das Label.

* required: Ob die Eingabe ein Pflichteingabe ist. Standard: false

* inputStyleClass: Die CSS-Klasse für den Eingabebereich. Standard: col-lg-6

* disabled: Ob die Checkbox deaktiviert ist oder nicht. Standard: false

* validationModel: Ein spezifisches Validation-Model, falls benötigt

* globalConfig: Eine spezifische globale Konfiguration, falls benötig


Seit 4.0

* required: Ob die Eingabe eine Pflichteingabe ist. (rotes Sternchen)

* optional: Ob die Eingabe eine Optionale-Pflichteingabe ist. (blaues Sternchen)

* valueChangeListener: Die Listener-Methode, die bei einem Change Event aufgerufen wird.

[[radio-button-ueberschrift]]
==== Radio Button

Radio Buttons dienen der eindeutigen Auswahl von sich ausschließenden Optionen.
Der Benutzer kann also nur eine der Optionen auswählen.

:desc-image-ieradiobutton: Radio Button – Darstellungsbeispiel IE 9
[id="image-ieradiobutton",reftext="{figure-caption} {counter:figures}"]
.{desc-image-ieradiobutton}
image::image193.png[align="center", width="129",height="65"]


Ein Radio Button wird über das Tag `<isy:selectOneRadio>` (bzw. `<isy:selectOneRadioInline>` , seit 3.1.x. und `<isy:formSelectOneRadio>`, seit 4.0.x) eingebunden.

Folgende Parameter sind für `<isy:selectOneRadioInline>` zulässig:


* value: Der Wert der Auswahl für das Data-Binding

* selectItems: Die Select-Items.
Jedes Item entspricht einem Radio-Button


Für `<isy:selectOneRadio>` ist zusätzlich folgendes Attribut zulässig:

* disabled: Ob die Darstellung nur lesend erfolgen soll (seit 4.0.x)

(seit 4.0.x) Für `<isy:formSelectOneRadio>` sind zusätzlich folgende Attribute zulässig:


* value: Der Wert der Auswahl für das Data-Binding
* inline: Ob die Radio-Buttons inline angezeigt werden sollen oder nicht.
* reference: Die Referenz des Objekts.
* label: Der Text für das Label
* labelStyleClass: Die CSS-Klasse für das Label.
* inputStyleClass: Die CSS-Klasse für den Eingabebereich.
* required: Ob die Eingabe ein Pflichteingabe ist.
* validationModel: Ein spezifisches Validation-Model, falls benötigt.
* globalConfig: Eine spezifsche globale Konfiguration, falls benötigt.

[[navigation]]
==== Navigation

[[horizontale-navigation]]
===== Horizontale Navigation

Derzeit wird die Navigationsleiste im Header Bereich statisch geladen.
Jede Anwendung muss daher die Ressource `/WEB-INF/gui/common/s eitenelemente/navigation.xhtml` mit einer spezifischen Anpassung überschreiben.
Zukünftig soll eine Konfiguration der Links möglich sein.


[[linksnavigation]]
===== Linksnavigation

Die Linksnavigation ist ein optionales Element und kann zur weiteren Strukturierung einer Applikation dienen.
Sie kann über ein Icon ein- und ausgeblendet werden. 

Linksnavigationen werden durch den Controller LinksnavigationController und das Model LinksnavigationModel realisiert.
Der Controller ist bereits im ApplikationseiteController eingebunden und muss daher nicht explizit aktiviert werden.

Linksnavigationen werden in der Konfigurationsdatei gui-linksnavigation.properties konfiguriert.
Die Konfigurationsdatei liegt im

Deployment, es handelt sich nicht um eine betriebliche Konfiguration.
Die Konfiguration muss in der Konfigurationsbean "konfiguration" eingebunden werden. Über die Variable gui.linksnavigation.ids wird zunächst eine Liste an IDs für die jeweiligen Linksnavigationen konfiguriert, z. B.:

`gui.linksnavigation.ids=linksnavigationbeispiel, jsfSteuerelemente`

Für jede vergebene ID wird eine Linksnavigation wie folgt konfiguriert:

`gui.linksnavigation.linksnavigationbeispiel.headline=Beispiellinkliste`
`gui.linksnavigation.linksnavigationbeispiel.1.text=Beispielseite A`
`gui.linksnavigation.linksnavigationbeispiel.1.link=beispiellinkaFlow`
`gui.linksnavigation.linksnavigationbeispiel.2.text=Beispielseite B`
`gui.linksnavigation.linksnavigationbeispiel.2.link=beispiellinkbFlow`

`gui.linksnavigation.jsfSteuerelemente.headline=Überschrift`
`gui.linksnavigation.jsfSteuerelemente.1.text=JSF-Steuerlemente`
`gui.linksnavigation.jsfSteuerelemente.1.link=jsfSteuerelementeFlow`

Anhand des aktuell aktiven Flows wird automatisch die korrekte Linksnavigation dargestellt und der enthaltene Link zum aktiven Flow wird entsprechend als ausgewählt dargestellt.
Wenn ein Subflow aktiv ist, dann wird immer der ursprünglich aufrufende Flow als der aktive Flow angesehen. Wenn keine passende Linksnavigation gefunden wird, dann wird keine dargestellt.
Weiterhin kann auf einer Applikationsseite eine individuelle Linksnavigation manuell eingebunden werden.

[[quicklinks]]
===== Quicklinks

Muss der Benutzer häufig auf bestimmte Funktionen oder Objekte in einer Anwendung zugreifen, so kann es sinnvoll sein ihm Schnellzugriffe, sogenannte Quicklinks auf diese Funktionen/Objekte zur Verfügung zu stellen.

:desc-image-quicklinksunterhalblinksnavigation: Quicklinks unterhalb der Linksnavigation
[id="image-quicklinksunterhalblinksnavigation",reftext="{figure-caption} {counter:figures}"]
.{desc-image-quicklinksunterhalblinksnavigation}
image::image202.png[align="center", width="240",height="400"]

:desc-image-quicklinksaufdashboard: Quicklinks auf Dashboard
[id="image-quicklinksaufdashboard",reftext="{figure-caption} {counter:figures}"]
.{desc-image-quicklinksaufdashboard}
image::image203.png[align="center", width="240",height="400"]

Quicklinks werden durch den Controller `QuicklinksController` und das Model `QuicklinksModel` realisiert.
Der Controller kann in einen beliebigen Controller eingebunden werden und durch Aufrufe können die darzustellen Quicklinks gesteuert werden.

Quicklinks können hinzugefügt werden, indem im Controller `QuicklinksController` die Methode `fuegeQuicklinkHinzu(QuicklinkselementModel` `quicklinkselementModel`) aufgerufen wird.
Ein einzelner Quicklink (QuicklinkselementModel) besitzt folgende Attribute:


* `id`: Die ID eines Quicklinks

* `anzuzeigenderText`: Der Text der angezeigt wird

* `link`: Der dahinterliegende Link


Mit der Methode `entferneQuicklink(String id)` können Quicklinks wieder entfernt werden.
Quicklinks werden in der Session abgespeichert.

Die zuletzt hinzugefügten Quicklinks werden oben dargestellt. Wenn ein Quicklink hinzugefügt wird, der bereits vorhanden ist (Identifikation über seine ID), dann werden der Link und der anzuzeigende Text des Quicklinks aktualisiert und der Quicklink wird nach oben gesetzt. Wenn die maximale Anzahl an Quicklinks erreicht wird (konfigurierbar über den Konfigurationsparameter `gui.quicklinks.max.anzahl`), dann wird der älteste Quicklink entfernt.

Seit 3.1.x: Für Quicklinks kann es nun auch mehrere Gruppen geben (z.B. aktuelle Suchanfrage, letzte Suchanfragen)

Seit 4.1.x: Gruppen von Quicklinks können jetzt abhängig vom aktuellen Flow angezeigt werden.
Weiterhin ist es möglich nun die Quicklinksbereiche statisch (analog zur Linksnavigation zu konfigurieren). Hierzu können in der Konfiguration folgende Einstellungen hinterlegt werden:

* `gui.quicklinks.gruppenIds`: Die kommaseparierte Liste an vorkonfigurierten Quicklinksgruppen.
* `gui.quicklinks.<gruppeId>.text`: Der vorkonfigurierte Text der für die Gruppe angezeigt wird.
* `gui.quicklinks.<gruppeId>.contextflow`: Die kommaseparierte Liste an Startflows, welche die Anzeige der Gruppe erlauben.
Ist keine Konfiguration gesetzt, so wird die Gruppe immer angezeigt.


Gruppen können auch ohne Konfiguration (wie zuvor) existieren.
Die Konfiguration bietet lediglich einen statischen Weg zur Konfiguration der Quicklinksgruppen.


[[paginator]]
===== Paginator

Siehe Implementierungshinweise bei <<grosse-datenmengen-tabelle>>


====== Date Picker

Mit dem Date Picker kann der Benutzer per Klick auf das Kalender Icon ein Flyout öffnen, in dem der gewünschte Tag ausgewählt werden kann.
Im oberen Bereich kann der Benutzer zwischen den Monaten und Jahren wechseln.

Der Date Picker wird über das Tag `<isy:formDate>` eingebunden und gehört zu den Formulareingabekomponenten.

Folgende Parameter sind zulässig:

* reference: Die Referenz des Objekts für die Validierung.

* value: Der Wert für das Databinding im Eingabefeld.

* required: Ob die Eingabe ein Pflichteingabe ist.Standard: false

* label: Der Text für das Label.

* labelStyleClass: Die CSS-Klasse für das Label. Standard: col-lg-6

* inputStyleClass: Die CSS-Klasse für den Eingabebereich. Standard: col-lg-6

* placeholder: Der Platzhalter, welcher im Eingabefeld angezeigt wird.

* language: Die Sprache für den Datepicker. Standard: de (Seit 3.1.x)

* dateFormat: Das Datumsformat für den Datepicker. Standard: dd.mm.yyyy (Seit 3.1.x)

* inputMask: Das Maskenformat für das Eingabefeld. Standard: 99.99.9999 (Seit 3.1.x)

* validationModel: Ein spezifisches Validation-Model, falls benötigt

* globalConfig: Eine spezifische globale Konfiguration, falls benötigt


Für den Datepicker wird ein externes Plug-In verwendet.
Das Feld an sich verhält sich also so, wie es das Plug-In vorgibt.

===== Time Picker

Mit Hilfe des Time Pickers kann der Benutzer Uhrzeiten auswählen.

Derzeit noch nicht umgesetzt.

===== Buchstaben Picker

Der Buchstaben Picker kann den Benutzer bei der Auswahl bestimmter Buchstaben unterstützen z.B. zur Auswahl von Anfangsbuchstaben.

Ein Charpicker für Sonderzeichen kann durch die Angabe von `charpicker=true` in einem Formulareingabefeld (`<isy:formInput>`) aktiviert werden (seit 3.1.x).

===== List Picker (Objektauswahl)

Der List Picker kann den Benutzer bei der Auswahl bestimmter Objekte unterstützen, in dem weitere Zusatzinformationen die Identifikation von Werten vereinfachen.

Ein List Picker wird über das Tag `<isy:formListpicker>` eingebunden und gehört zu den Formularkomponenten.

Folgende Parameter sind zulässig:


* reference: Die Referenz des Objekts für die Validierung

* value: Der Wert für das Databinding im Eingabefeld

* required: Ob die Eingabe ein Pflichteingabe ist. Standard: false

* label: Der Text für das Label.

* labelStyleClass: Die CSS-Klasse für das Label. Standard: col-lg-6

* inputStyleClass: Die CSS-Klasse für den Eingabebereich. Standard: col-lg-6

* listpickerModel: Das Model für den Listpicker abgeleitet von ListpickerModel.

* listpickerController: Der Controller für den Listpicker abgeleitet von ListpickerController.

* header: Die sortierte Liste der Spaltenüberschriften.

* placeholder: Der Platzhalter, welcher im Eingabefeld angezeigt wird.

* inputmask: Die Eingabemaske für das Feld.

* ajaxLoading: Ob Items dynamisch nachgeladen werden sollen. Standard: false

* ajaxForm: Die ID des Formulars, welches für das dynamische Nachladen von Items verwendet wird.

* inputComplement: Die Nummer der Headerspalte, dessen Inhalt per Javascript im Eingabefeld ergänzt werden soll, sobald das Feld verlassen wird (z.B. Schlüsselwert zu Schlüssel anzeigen). Standardmäßig 0 = deaktiviert.

* validationModel: Ein spezifisches Validation-Model, falls benötigt

* globalConfig: Eine spezifische globale Konfiguration, falls benötigt


Falls JavaScript nicht aktiviert ist, dann wird statt dem List Picker ein einfaches Dropdown angezeigt.

Beispiel für die Integration eines List-Pickers (ohne Ajax)

:desc-listing-listpickerOhneAjax: Listpicker ohne Ajax
[id="listing-listpickerOhneAjax",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-listpickerOhneAjax}
[source, xml]
----
<isy:formListpicker
  reference="anfrageIdentifikation.gruppe"
  inputmask="99"
  listpickerModel="#\{identifikationModel.gruppeListpickerModel}"
  listpickerController="#\{behoerdeHelper.gruppeListpickerController}"
  label="#\{msg.MEL_Identifikation_Gruppe}"
  value="#\{identifikationModel.anfrageIdentifikation.gruppe}"
  header="#\{msg.MEL_Identifikation_Gruppe_Listpicker_Nummer},
          #\{msg.MEL_Identifikation_Gruppe_Listpicker_Name} "/>
----

Das spezifsche ListpickerModel enthält die Liste an Items, welche dargestellt werden sollen.
Die Filterung der Items geschieht automatisch über JavaScript.
Falls die Liste an Items zu groß wird, besteht die Möglichkeit die Auswahl über AJAX nachzuladen.
Dazu können die Attribute ajaxL oading="true" und ajaxForm="gruppeListpickerAjaxForm" ergänzt werden.
Zusätzlich muss im View State das entsprechende Form Element ergänzt werden:

:desc-listing-listpickerAjaxForm: ListpickerAjaxForm
[id="listing-listpickerAjaxForm",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-listpickerAjaxForm}
[source, xml]
----
<ui:define name="form">
   <h:form id="gruppeListpickerAjaxForm">
      <isy:formListpickerAjaxContent
      listpickerModel="#\{identifikationModel.gruppeListpickerModel}" />
   </h:form>
</ui:define>
----
Über das `<ui:define>` lassen sich Form-Elemente im Basis-Layout integrieren.
Das Tag `<isy:formListpickerAjaxContent>` lädt die entsprechend ListpickerItems in das Formular.
Das Formular an sich ist nicht sichtbar.
Das JavaScript Plugin übernimmt das entsprechende Laden der Elemente in den Listpicker.
Die Filterung der Elemente kann im spezifischen ListpickerController definiert werden.

Für die Auswahl von Behörden existiert bereits ein fertiger Behördenlistpicker (`<isy:formBehoerdeListpicker>`), welcher den normalen Listpicker instanziiert.
Der Behördenlistpicker ist ein AJAX Listpicker, d.h. es muss immer ajaxForm angegeben werden.
Als Dropdown zeigt er eine zweispaltige Tabelle mit Behördenkennzeichen und Namen der Behörde an, auf welcher gefiltert werden kann.
Er besitzt folgende Parameter:


* reference: Die Referenz des Objekts für die Validierung

* value: Der Wert für das Databinding im Eingabefeld (muss vom Typ Listpickerangabe sein)

* required: Ob die Eingabe ein Pflichteingabe ist. Standard: false

* label: Der Text für das Label.

* labelStyleClass: Die CSS-Klasse für das Label. Standard: col-lg-6

* inputStyleClass: Die CSS-Klasse für den Eingabebereich. Standard: col-lg-6

* listpickerModel: Das Model für den Listpicker als Instanz von BehoerdeListpickerModel.

* listpickerController: Der Controller für den Listpicker abgeleitet von AbstractBehoerdeListpickerController mit spezifischer Implementierung der Anwendung.

* placeholder: Der Platzhalter, welcher im Eingabefeld angezeigt wird.

* ajaxForm: Die ID des Formulars, welches für das dynamische Nachladen von Items verwendet wird.

* validationModel: Ein spezifisches Validation-Model, falls benötigt

* globalConfig: Eine spezifische globale Konfiguration, falls benötigt

[[editaable-row]]
===== Editable Row

Editable Rows sind flexible Zeilen deren Inhalte separat bearbeitet werden können.

Derzeit nicht umgesetzt.

[[selektion-ueberschrift]]
==== Selektion

Patterns zur Selektion von Daten

[[suche-ueberschrift]]
===== Suche

Ein Beispiel zur Umsetzung eines Suchformulars findet sich hier: Hinweise zur Implementierung von Formularen

[[filter-ueberschift]]
===== Filter

Diese Funktion ist derzeit noch nicht umgesetzt.


===== Toggle Filter

(Seit 4.0.x) Ein Toggle-Filter wird über das Tag `<isy:toggleFilter>` eingebunden.
Folgende Parameter sind zulässig:


* action: Die auszuführende Aktion.

* label: Der Text für das Label.

* value: Der ausgewählt Filter.

* styleClass: Optionale CSS Style Klasse.

* execute: AJAX: Welche Felder ausgewertet werden sollen.

* render: AJAX: Welcher Teilbereich aktualisiert werden soll.

* globalConfig: Eine spezifische globale Konfiguration, falls nötig.


===== Filter Zeile

Die Implementierung erfolgt über das Facet

 `<f:tableFilter>`
die Tags
 `<dataTableFilter>`
und
 `<dataTableFilterCleaner>`
und den dazugehörigen
 `dataTableFilterModel`.


Im Allgemeinen muss beim `<dataTableFilter>` Tag nur die Eigenschaft angegeben werden, nach der man filtern will.
Damit wird einen normalen Eingabefeld für die Filterung zur verfügung gestellt.
Es gibt auch die Möglichkeit die Filterung über eine Dropdownliste zu ermöglichen, dafür müssen die mögliche Einträge im Tag verschachtet angegeben werden.

**Hinweis**:Es ist besonders wichtig, dass die Anzahl der Spalten im Header, Filter-Zeile und Body übereinstimmen.
Dies wird auch in Javascript überprüft, und ggf.
bekommt der Entwickler eine Fehlermeldung.
Bei Spalten die nicht gefiltert werden sollen (bzw.
können), wie z.B. die Spalte mit den Checkboxen, muss man einen Platzhalter mit dem Tag <dataTableFilter > ohne Attribute angeben.

*Beispiel:*

:desc-listing-bspTableFilter: Beispiel für tableFilter
[id="listing-bspTableFilter",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-bspTableFilter}
[source, xml]
----
<f:facet name="tableFilter">
   <!-- Platzhalter für checkbox Spalte -->
   <isy:dataTableFilter />
     <isy:dataTableFilter property="anrede" dropdown="true">
         <f:selectItem itemValue="" itemLabel="Wählen Sie aus:" />
         <f:selectItems value="#\{dropdownHelper.anredeListe}" />
      </isy:dataTableFilter>
      <isy:dataTableFilter property="vorname" />
      <isy:dataTableFilter property="nachname" />
      <isy:dataTableFilter property="geburtsdatum" />
   <isy:dataTableFilterClearer />
</f:facet>
----

*Kein JavaScript*

image::image131.png[image,width=54,height=54]

Die Komfortfunktionen der Filter-Zeile können ohne JavaScript nicht zur Verfügung gestellt werden.
Die Filter-Zeile ist in diesem Fall nicht vorhanden und wird auch nicht angezeigt.

[[browse-und-collect]]
===== Browse & Collect

Mit Browse & Collect kann der Benutzer eine Liste von Objekten erstellen.
Hierbei werden Objekte von einer Quellliste in eine Zielliste übertragen.

(Seit 4.0.x) Browse and Collect kann über das Tag `<isy:formBrowseAndCollect>` und `<isy:browseAndCollect>` eingebunden werden.
Folgende Parameter sind für `<isy:browseAndCollect>` zulässig:


* reference: Die Referenz des Objekts.
* value: Der Wert der Auswahl für das Databinding.
* disabled: Ob die Liste deaktiviert ist.
* browsecollectStyleClass: Die CSS-Klasse für die Komponente.
* size: Dieses Attribut wird im Sinne von bootstrap-selectlist.js interpretiert, d.h. gibt die Anzahl der Zeilen die sichtbar sind.
* globalConfig: Eine spezifische globale Konfiguration, falls notwendig.


Folgende Parameter sind zusätzlich für `<isy:formBrowseAndCollect>` zulässig:

* label: Der Text für das Label.
* labelStyleClass: Die CSS-Klasse für das Label.
* inputStyleClass: Die CSS-Klasse für den Eingabebereich.
* validationModel: Ein spezifisches Validation-Model, falls benötigt.

[[datentabelle]]
===== Datentabelle

Details zur Umsetzung finden sich hier: <<tabelle-ueberschrift>>

[[datenvorschau]]
===== Datenvorschau

Die Datenvorschau kann zur Vorschau oder Zusammenfassung von komplexen Daten dienen.

Details zur Umsetzung finden sich hier: <<Tabelle>>


[[master-detail]]
===== Master-Detail

Bei dem Master-Detail Konzept werden Informationen eines Master-Objekts und dessen Details auf einer Seite dargestellt.
Zum Beispiel kann eine Liste von Objekten in einer Tabelle (Master) dargestellt werden.
Die dazugehörigen Informationen (Detail) werden je nach Layout in einem Bereich darunter oder daneben angezeigt.

Die Master-Detail Ansicht kann durch die Nutzung von einfachen Elementen (Tabelle, Buttons, bedingtes Rendern (ui:fragment)) umgesetzt werden.

[[gruppierung]]
==== Gruppierung

Patterns zur Gruppierung von Daten

Ein Expander kann durch die Angabe von `collapse="true"` und der Angaben eines entsprechenden Panel Models in der Komponente `<isy :panel>` erzeugt werden. Über das PanelModel lässt sich auch der Initialzustand steuern.

*Gruppierungs-Container*

Durch die Angabe von `<isy:panel>` können entsprechene Gruppierungs-Container erstellt werden.
Das Tag hat folgende Parameter/Attribute:

* collapse: Ob das Panel einklappbar sein soll.
Falls ja, so muss auch ein panelModel angegeben werden.
* panelModel: Das Panel Model.
Das Panel Model.
Nur Notwendig falls das Panel einklappbar sein soll.
Das Panel Model sollte Teil des Seitenmodels sein.
* globalConfig: Eine spezifische globale Konfiguration, falls notwendig.


Das Tag bietet folgende Facets:

* panelHeader: Zur Angabe des Headers

__Hinweis__: Derzeit existiert noch kein vereinfachter Weg zur Angabe von Buttons/Icons im Panel.
Diese müssen also über den panelHeader eigenständig definiert werden.

Zur Gruppierung von mehreren Panels sollte das Tag `<isy:panelGroup>` verwendet werden.
In diesem können die anderen Panels geschachtelt werden.
Das Tag besitzt folgende Parameter:

* headerPanel: Ob die Gruppe als Container für den Header des Inhaltesbereichs dient.
Falls ja werden entsprechende CSS-Klassen für das Layouting eingebunden.

===== Seiten Toolbar

Die Seitentoolbar ist Teil des BasisModel.
Auf das SeitentoolbarModel kann daher über den BasisController zuegriffen werden.
Der ApplikationseiteController und der DetailseiteController konfigurieren dieses Model entsprechend den Vorgaben automatisch.

Über die Template-Engine (ui:insert/ui:define) werden weiterhin folgende Bereiche zur Verfügung gestellt.
Konkrete Seiten können dadurch Einfluss auf das Aussehen der Seitentoolbar nehmen:

* seitentoolbarLinksButtons: Fügt Anpassungen auf der linken Seite ein.
* seitentoolbarMitteButtons: Fügt Anpassungen in der Mitte (zentriert) ein.
* seitentoolbarRechtsButtons: Fügt Anpassungen auf der rechten Seite ein.

===== Tabellen Toolbar

Derzeit noch nicht umgesetzt.

[[layout-von-Formularen]]
==== Layout von Formularen

*Definition von Formularen*

Die Umsetzung von Formularen erfolgt mit den gängigen Bootstrap CSS Klassen.
Um ein einfaches Suchformular umzusetzen genügt z.B. folgender Code:

:desc-listing-bspFormularumsetzung: Beispiel für Formularumsetzung
[id="listing-bspFormularumsetzung",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-bspFormularumsetzung}
[source, xml]
----
<div class="form-horizontal">
   <div class="row row-df">
      <div class="col-lg-6"> <isy:formInput reference="vorname" ... />
         <isy:formInput reference="nachname" .... />
      </div>
      <div class="col-lg-6">
         <isy:formInput reference="geburtsort" ... />
         <isy:formSelectOneDropdown reference="geschlecht" ... />
         <isy:formListpicker reference="staatsangehoerigkeit" ... />
      </div>
   </div>
 </div>
 ...

<isy:buttonRow alignRight="true">
   <isy:button id="suchen"
      action="suchen"
      value="#\{msg_currentflow.MEL_Suchleiste_BTN_Suchen}" />
   <isy:button id="suchfelderLeeren"
      action="suchfelderLeeren"
      value="#\{msg_currentflow.MEL_Suchleiste_BTN_SuchfelderLeeren}" />
</isy:buttonRow>
----

Durch die Angabe von `form-horizontal` wird der Bereich für das Formular definiert.
Mit Angabe von `row row-df` beginnt die Nutzung des Bootstrap Scaffoldings `(row-df` ist dabei eine Spezialanpassung zur Nutzung von Bootstrap unter IE8 ohne JavaScript).


*Formularkomponenten*

Neben den normalen Bedienkomponenten existieren auch Formularkomponenten (erkennbar an dem Präfix `<isy:form...>`). Diese Komponenten integrieren sich direkt in ein Formular.
Sie bringen ein Label sowie eine Integration in den Validierungsmechanismus mit sich.
Die einzelnen Formularkomponenten werden in den jeweiligen Kapiteln der Bedienelemente beschrieben.

(Seit 3.1.x) In den Formularen kann durch das Angeben von `<isy:formDefaultButton> eine Standardbutton zur Auslösung definiert werden.
Beim Drücken auf "Enter" wird dann diese Aktion ausgeführt.
Die Funktionalität ist nur bei aktiviertem JavaScript verfügbar. 

(Seit 3.1.x) Um anwendungsspezifische Elemente in ein Formular zu integrieren, kann das Tag `<isy:formCustom>` verwendet werden.
Die Elemente innerhalb dieses Tags werden dann mit Label an der korrekten Stelle im Formular angezeigt (z.B. anstatt eines Eingabefelds bei Nutzung von formInput). Die Komponente unterstützt folgende Attribute:


* reference: Die Referenz des Objekts für die Validierung

* label: Der Text für das Label.

* labelStyleClass: Die CSS-Klasse für das Label. Standard: col-lg-6

* inputStyleClass: Die CSS-Klasse für den Eingabebereich. Standard: col-lg-6

* breakWords: Erlaubt das Deaktivieren des Wrappings von Text innerhalb der Komponente.

* globalConfig: Eine spezifische globale Konfiguration, falls benötigt

Die Komponente besitzt folgende Facets:

* contentRight: Der Inhalt, der rechts vom eingefügten Element angezeigt wird.

[[autosuggestion]]
==== Autosuggestion

Derzeit noch nicht umgesetzt.

[[platzhalter-ueberschrift]]
==== Platzhalter

Platzhalter können über das Attribut placeholder in den Eingabekomponenten angegeben werden.
Die Angabe von Platzhaltern ist derzeit noch nicht in allen Eingabekomponenten möglich.


[[tooltips-ueberschrift]]
==== Tooltips

(Seit 4.0.x) Für das einbinden eines Tooltips kann das Tag `<isy:tooltip>` verwendet werden.
Es besitzt folgende Parameter:

* text: Der Text, der bei Hover über das Element angezeigt werden soll.
* title: Eine optionale Überschrift die fett über den Text angezeigt wird.


[[fortschrifttsanzeige]]
==== Fortschrittsanzeige

Derzeit noch nicht umgesetzt.


[[anzeige-optionale-Pflichtfelder]]
==== Anzeige von Pflichtfeldern und optionalen Pflichtfeldern

Derzeit nur teilweise umgesetzt.
Pflichtfelder können über die Angabe des Attributs required in der entsprechenden Komponentendefinition gesetzt werden.

Eine Umsetzung für optionale Pflichtfelder fehlt derzeit.


[[validierung-ueberschrift]]
==== Validierung

_Nachrichten_

Der MessageController erlaubt es, Nachrichten auszugeben.
Folgende Methoden für Hinweismeldungen, Erfolgsmeldungen, Warnmeldungen und Fehlermeldungen werden angeboten:

*  void writeInfoMessage(String information)
*  void writeSuccessMessage(String success)
*  void writeWarnMessage(String warning, String summary)
*  void writeErrorMessage(String error, String summary)

Weiterhin können die aktuell vorhandenen Meldungen ausgelesen werden:

*  List<FacesMessage> getCurrentInfoMessages()
*  List<FacesMessage> getCurrentSuccessMessages()
*  List<FacesMessage> getCurrentWarnMessages()
*  List<FacesMessage> getCurrentErrorMessages()

Nachrichten werden über das Tag `<isy:messages>` im Basis-Layout gerendert.
Dies geschieht automatisch und ohne weiteres zutun.

_Validierung_

Mit dem ValidierungController können Validierungsmeldungen hinzugefügt werden, indem folgende Methode aufgerufen wird:

* void processValidationMessages(List<ValidationMessage> validationMessages)


Eine einzelne Validierungsmeldung besteht dabei aus folgenden Attributen:

* code: Der (Fehler)Code der Nachricht (z. B. "XYZ")

* reference: Die Referenz auf den Fehler ( z. B. "person.geburtsdatum")

* readableReference: Die lesbare Darstellung der Referenz (z. B. "Geburtsdatum")

* message: Die Fehlernachricht


Validierungsmeldungen werden nur für den aktuellen Aufruf (FlashScope) angezeigt.
Wenn JavaScript nicht aktiviert ist, werden alle Validierungsfehler in einer Liste angzeigt.
Auf den Tooltip wird verzichtet.
Für die Zuordnung von Validierungsfehler und Eingabefeld wird das Attribut reference verwendet, welches auch in der entsprechenden Formularkomponente `<isy:form...>` angegeben werden muss.

Für den Einsatz mit der plis-validation (Bean Validation) wird bereits ein GuiValidator mitgeliefert, welcher direkt ValidationMessages liefert.
Diese können dann dem ValidationController übergeben werden.
Als Referenz wird dabei automatisch der Property-Path der ConstraintViolation verwendet.

=== JSF Seitenelemente


[[hauptfenster]]
==== Hauptfenster

Das im Styleguide beschriebene Anwendungslayout besteht im allgemeinen aus einem Hauptfenster mit einem Header und einem Inhaltsbereich, dessen Inhalt je nach Seitentyp und Applikation variieren kann.

:desc-image-aufbauapplikationsseite: Aufbau einer Applikationsseite
[id="image-aufbauapplikationsseite",reftext="{figure-caption} {counter:figures}"]
.{desc-image-aufbauapplikationsseite}
image::image57.png[align="center", width="629",height="526"]


*Aufbau*

* Header Bereich
* Linksnavigation (optional)
* Inhaltsbereich


[[header-bereich]]
===== Header Bereich

Der Header Bereich enthält allgemeine Informationen der Applikation.

:desc-image-headersolo: Header
[id="image-headersolo",reftext="{figure-caption} {counter:figures}"]
.{desc-image-headersolo}
image::image36.png[align="center", width="629",height="104"]

:desc-image-aufbaudesheaderbereichs: Aufbau des Header-Bereiches
[id="image-aufbaudesheaderbereichs",reftext="{figure-caption} {counter:figures}"]
.{desc-image-aufbaudesheaderbereichs}
image::image37.png[align="center", width="629",height="149"]


*Aufbau*

* *A* Logo des Portalanbieters
* *B* Farbmarkierung des Applikationsportals
* *C* Logo des Applikationsportals
* *D* Login-Information
* *E + F* Hauptnavigation und Subnavigation als Flyout (siehe Kapitel Horizontale Navigation)

[[headerbereich-bestandteile]]
===== Headerbereich Bestandteile

*_Navigationsleiste und Nutzerbereich_*

Derzeit wird die Navigationsleiste im Header Bereich noch statisch geladen.
Jede Anwendung muss daher die Ressource +
   `/WEB-INF/gui/common/seitenelemente/navigation.xhtml` +
mit einer spezifischen Anpassung überschreiben.


Der Nutzerbereich wird nicht von der isy-web zur Verfügung gestellt, da sich z.B. das Verhalten des Logout Buttons in verschiedenen Betriebsumgebungen unterscheiden kann (unterschiedliche HTTP Parameter, etc.). Konkrete Anwendungen müssen über die Konfigurationseinstellung `gui.header.nutzerbereich.xhtml.src` das XHTML angeben, welches den Nutzerbereich definiert.
Die Angabe der Konfiguration ist verpflichtend.

*_Titel_*

Den Titel gibt es nur auf Applikations-Detailseiten (s. Implementierungshinweise dort).


*_Maskentexte_*

Maskentexte, die nur innerhalb eines bestimmten Flows verwendet werden, können in der Konfigurationsdatei <Flow-Name>.properties im Ordner `resources/nachrichten/maskentexte` definiert werden.
Wenn die jeweilige Konfigurationsdatei vorhanden ist, werden die Maskentexte automatisch geladen und in die Variable msg_currentflow abgespeichert.
Die Maskentexte des jeweiligen Flows können dann beispielsweise wie folgt ausgelesen werden:

:desc-listing-maskentexteKonfigurierbar: Maskentexte über Konfiguratiosdatei
[id="listing-maskentexteKonfigurierbar",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-maskentexteKonfigurierbar}
[source, xml]
----
<h:outputText value="#\{msg_currentflow.MAS_Ueberschrift}" />
----

Auf übergreifende Maskentexte aus der Konfigurationsdatei 
`resources/nachrichten/maskentexte.properties` 
kann über die Variable msg zugegriffen werden.

===== Applikationsseiten

Applikationsseiten werden über den Controller `ApplikationseiteController` und das Model `ApplikationseiteModel` realisiert.

Wenn eine Applikationsseite erstellt werden soll, dann muss der Flow der Applikationsseite vom Flow `applikationseiteParentFlow` erben.
Es muss weiterhin ein Controller erstellt werden, der vom `AbstractGuiController` erbt und ein Model, das vom `AbstractMaskenModel` erbt. Die XHTML-Seiten der ViewStates müssen alle vom Template `/WEB-INF/gui/common/layout/applikation.xhtml` erben.

Der `ApplikationseiteController` stellt sicher, dass alle layoutspezifischen Funktionen (z.B. der Linksnavigation) einer Applikationsseite initialisiert und zur Verfügung gestellt werden.
Abweichungen vom Standardvorgehen (z.B. Linksnavigation ausblenden) können durch Zugriff auf den Controller und Model in spezifischeren Controllern beim Initialisieren durchgeführt werden.

Neben dem `ApplikationseiteController` existiert auch der `BasisController`.
Dieser bietet Zugriff auf seitentypunabhängige Layoutfunktionen (z.B. modalen Dialog anzeigen).

Siehe weiterhin die Hinweise in den Seiten Header Bereich, Linksnavigation und Quicklinks.

===== Applikation Detailseite

Applikationsdetailseiten werden über den Controller `DetailseiteController` und das Model `DetailseiteModel` realisiert.

Wenn eine Applikationsdetailseite erstellt werden soll, dann muss der Flow der Applikationsdetailseite vom Flow `detailseiteParentFlow` erben.
Es muss weiterhin ein Controller erstellt werden, der vom `AbstractGuiController` erbt und ein Model, das vom `AbstractMaskenModel` erbt.
Die XHTML-Seiten der ViewStates müssen alle vom Template `/WEB-INF/gui/common/layout/applikationDetailseite.xhtml` erben.

Der DetailseiteController stellt sicher, dass alle layoutspezifischen Funktionen (z.B. der Seitentoolbar sowie Buttons in der Toolbar) einer Detailseite initialisiert und zur Verfügung gestellt werden.
Abweichungen vom Standardvorgehen (z.B. Seitentoolbar ausblenden, Druckbutton einblenden, Informationsbereich einblenden) können durch Zugriff auf den Controller und Model in spezifischeren Controllern beim Initialisieren durchgeführt werden.

Neben dem `DetailseiteController` existiert auch der `BasisController`.
Dieser bietet Zugriff auf seitentypunabhängige Layoutfunktionen

(z.B. modalen Dialog anzeigen).

_Titel_

Der TitlesListener (Listener für Spring-Webflow) ermöglicht es, dass konfigurierte Nachrichten anhand von Namenskonventionen automatisch als Title (Title-Tag), Headline (Titelzeile) oder Breadcrumb verwendet werden.
Der TitlesListener ist automatisch eingebunden und muss nicht explizit aktiviert werden.

Folgende Angaben sind zulässig:

`MAS_\{FlowName}_Title` +
`MAS_\{FlowName}_\{ViewState}_Title` +
`MAS_\{FlowName}_Headline` +
`MAS_\{FlowName}_\{ViewState}_Headline` +
`MAS_\{FlowName}_Breadcrumb` +
`MAS_\{FlowName}_\{ViewState}_Breadcrumb`

Die Angaben müssen sich in den Anwendungsressourcen (analog zu anderen Nachrichten) befinden und über eine MessageSource-Bean ("messageSource") der PLIS-Web zur Verfügung gestellt werden.

Wenn vorhanden, werden stets die Angaben mit ViewState verwendet, ansonsten die Angaben ohne ViewState.
In der Flowdefinition können die zu verwendenden Texte überschrieben werden, indem die Attribute titleKey , breadcrumbKey und headlineKey gesetzt werden.
Wenn für

den Title keine Angabe gefunden werden kann, dann wird der Wert von MAS_Global_Title verwendet.
Weiterhin kann mit `MAS_Global_Title_Prefix` ein globaler Präfix für den Title gesetzt werden.

Weiterhin kann über eine Angabe von `<ui:define name="titel"/>` in Seiten definiert werden, welche Inhalte rechts neben dem bereits definierten Title (Title-Tag) ausgegeben werden (seit Version 3.1.x der plis-web). Im Folgenden ein Beispiel:

:desc-listing-zusatzmaskentitel: Zusatz-Maskentitel im Headerbereich
[id="listing-zusatzmaskentitel",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-zusatzmaskentitel}
[source, xml]
----
<ui:define name="titel"> 
   <h:outputText value="zusätzlicher Text" /> </ui:define> Über die Angaben
<ui:define name="titelzeileInfoLinks"/> bzw. <ui:define name="titelzeileInfoRechts"/> kann
----

weiterhin definiert werden, welche Inhalte zusätzlich direkt rechts neben der Headline (Titelzeile) angezeigt werden bzw.
ganz am rechten Rand der Headline angezeigt werden (seit Version 3.1.x der plis-web). Im Folgenden ein Beispiel: 

:desc-listing-titelzeileninfo: Titelzeileninfo
[id="listing-titelzeileninfo",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-titelzeileninfo}
[source, xml]
----
<ui:define name="titelzeileInfoLinks"> 
   <h:outputText value="zusätzlicher Text" /> 
</ui:define>
<ui:define name="titelzeileInfoRechts"> 
   <h:outputText value="zusätzlicher Text" /> 
</ui:define>
----

_Hinweis:_ Die Breadcrumbfunktionalität ist derzeit noch nicht vollständig umgesetzt.

==== Dialoge

Modale Dialoge werden mit dem Tag `<isy:modalDialogContent>` definiert.
Der Dialog besitzt folgende Facets:
* Der Header-Bereich
* Der Body-Bereich
* Der Footer-Bereich


Beispiel:

:desc-listing-jspModalerDialog: Modaler Dialog
[id="listing-jspModalerDialog",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-jspModalerDialog}
[source, xml]
----
<ui:define name="modalDialog">
   <isy:modalDialogContent>
     <f:facet name="modalHeader">\{msg.MEL_Lichtbild_anzeigen_Titel}</f:facet>
     <f:facet name="modalBody">
     <div class="form-horizontal">
        ...
     </div>
     </f:facet>
     <f:facet name="modalFooter">
        <div class="form-horizontal readonly">
           ...
        </div>
      </f:facet>
   </isy:modalDialogContent>
 </ui:define>
----

Das Tag `<isy:modalDialogContent>` wird über den UI-Platzhalter modalDialog eingefügt.
Dieser Platzhalter sorgt dafür, dass je nach JavaScript Verfügbarkeit, der Inhalt des modalen Fensters entweder als Inhalt oder als eigenständiger Dialog gerendert wird.
Die Funktionsweise des modalen Dialogs ist in das Basis-Layout eingebunden.
Um einen Dialog zu öffnen muss dieser als eigener View-State (in Spring-Webflow) definiert werden.
Beim Eintreten in den Flow wird das modale Fenster über einen Aufruf des BasisController geöffnet.
Beim Verlassen des View-States wird dieser wieder geschlossen.
Beispiel:

:desc-listing-openCloseModaleDialoge: Öffnen und Schließen von modalen Dialogen
[id="listing-openCloseModaleDialoge",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-openCloseModaleDialoge}
[source, xml]
----
<view-state id="lichtbildAnzeigenViewState" model="maskenModel">
   <on-entry>
      <evaluate expression="basisController.showModalDialog()"/>
   </on-entry>

   ...

   <transition on="schliesseModalenDialog" to="gesamtauskunftAnzeigenViewState">
      <evaluate expression="basisController.hideModalDialog()"/>
   </transition>

</view-state>
----

Um im Hintergrund weiterhin das aktuelle Fenster anzuzeigen, genügt es den bisherigen View-State entsprechend zu vererben.

[[dialoge-ohne-javascript]]
===== Dialoge ohne JavaScript

image::image77.png[image,width=35,height=33]

Die modalen Dialoge werden automatisch in das Layout integriert, sofern kein JavaScript verfügbar ist.

:desc-image-keinjavascriptdialog: Kein JavaScript – Dialog
[id="image-keinjavascriptdialog",reftext="{figure-caption} {counter:figures}"]
.{desc-image-keinjavascriptdialog}
image::image78.png[align="center", width="629",height="525"]

:desc-image-keinjavascriptmeldung: Kein JavaScript – Meldungsdialog
[id="image-keinjavascriptmeldung",reftext="{figure-caption} {counter:figures}"]
.{desc-image-keinjavascriptmeldung}
image::image79.png[align="center", width="629",height="526"]

:desc-image-keinjavascriptwizard: Kein JavaScript – Wizard
[id="image-keinjavascriptwizard",reftext="{figure-caption} {counter:figures}"]
.{desc-image-keinjavascriptwizard}
image::image80.png[align="center", width="629",height="525"]


===== Meldungsdialoge

Meldungsdialoge werden eingesetzt, wenn der Benutzer in seinem Arbeitsablauf unterbrochen werden muss.

:desc-image-meldungsdialogobjloeschen: Meldungsdialog – Objekt löschen
[id="image-meldungsdialogobjloeschen",reftext="{figure-caption} {counter:figures}"]
.{desc-image-meldungsdialogobjloeschen}
image::image82.png[align="center", width="329",height="163"]


:desc-image-aufbaumeldungsdialog: Aufbau Meldungsdialog
[id="image-aufbaumeldungsdialog",reftext="{figure-caption} {counter:figures}"]
.{desc-image-aufbaumeldungsdialog}
image::image83.png[align="center", width="325",height="162"]


Für Meldungsdialoge gibt es derzeit keine Umsetzung.
Bei Bedarf können diese über die normalen modalen Dialoge umgesetzt werden (Dialoge).

[[wizard]]
===== Wizard

Mit „Wizard", auch Assistent genannt, wird eine geführte Abfolge von Interaktionsschritten bezeichnet.

:desc-image-dialogwizard1: Beispiel eines Dialog Wizards
[id="image-dialogwizard1",reftext="{figure-caption} {counter:figures}"]
.{desc-image-dialogwizard1}
image::image88.png[align="center", scaledwidth="96%"]

Der Wizard ist in der plis-web ab Version 3.1.x verfügbar. Wizards werden mit dem Tag <isy:wizard> definiert.

Folgende Parameter sind zulässig:

* wizardDialogModel: Das Model des Wizards
* width: Die Breite des modalen Dialogs (optionale Angabe)
* globalConfig: Eine spezifische globale Konfiguration, falls notwendig


Der Wizard besitzt folgende Facets:

* wizardHeader: Der Header-Bereich
* wizardBody: Der Body-Bereich
* modalFooter: Der Footer-Bereich
* wizardFooterRightButtons: Ergänzungen zu den angezeigten Buttons auf der linken Seite
* wizardFooterLeftButtons: Ergänzungen zu den angezeigten Buttons auf der rechten Seite

Beispiel:

:desc-listing-wirardModaleDialoge: Modaler Wizard
[id="listing-wirardModaleDialoge",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-wirardModaleDialoge}
[source, xml]
----
<isy:wizard wizardDialogModel="#\{wdm}">
   <f:facet name="wizardHeader">Testheader</f:facet>
   <f:facet name="wizardBody">
       <ui:param name="aktuelleWizardSeite" value="#\{wdm.getActiveWizardDialogPage()}" />
       <!-- In Abhängigkeit der ID werden die entsprechenden Seiten angezeigt. -->
       <ui:fragment rendered="#\{wdm.getActiveWizardDialogPageId().equals('1')}">
          <ui:include src="page1.xhtml" />
       </ui:fragment>
       <ui:fragment rendered="#\{wdm.getActiveWizardDialogPageId().equals('2')}">
          <ui:include src="page2.xhtml" /> </ui:fragment>
       <ui:fragment rendered="#\{wdm.getActiveWizardDialogPageId().equals('3')}">
          <ui:include src="page3.xhtml" />
       </ui:fragment>
       <ui:fragment rendered="#\{wdm.getActiveWizardDialogPageId().equals('4')}">
          <ui:include src="page4.xhtml" />
       </ui:fragment>
   </f:facet>
</isy:wizard>
----
Eine einzelne Seite eines Wizards wird über ein WizardDialogPage-Objekt definiert.
Eine WizardDialogPage hat u.A. folgende Attribute:

* wizardDialogPageId: Eine ID, welche die Wizardseite eindeutig innerhalb des Wizards identifiziert
* pageDone: Seite wurde abgearbeitet
* pageSuccessful: Seite wurde erfolgreich oder nicht erfolgreich abgearbeitet
* pageDisabled: Seite wurde deaktiviert
* buttonCancelActivated: Ob der Button aktiviert ist oder nicht
* buttonPreviousActivated: Ob der Button aktiviert ist oder nicht
* buttonAbortActivated: Ob der Button aktiviert ist oder nicht
* buttonCompleteActivated: Ob der Button aktiviert ist oder nicht
* buttonNextActivated: Ob der Button aktiviert ist oder nicht
* title: Title der Wizardseite

Weiterhin muss zu einem Wizard ein WizardDialogModel-Objekt definiert werden. Ein WizardDialogModel hat folgende Attribute und Methoden:

* activeWizardDialogPageId: Die ID der aktuell aktiven Seite
* nextActiveWizardDialogPageId: Die ID der neuen Seite
* wizardDialogPages: Liste von den einzelnen Seiten des Wizards (WizardDialogPage-Objekte)
* public boolean isPageDone(String id): Ob die Seite mit der angegebenen ID schon abgearbeitet wurde.
* public boolean isPageDisabled(String id): Ob die Seite mit der angegebenen ID deaktiviert ist.
* public WizardDialogPage getActiveWizardDialogPage(): Gibt die momentan aktive Seite zurück.
* public WizardDialogPage getWizardDialogPage(String wizardDialogPageId): Gibt die Seite zur angegebenen ID zurück.

Für die Verwendung eines Wizards muss ein Controller erstellt werden, der vom `WizardDialogController` erbt.
Folgende Methoden müssen dabei überschrieben werden:

* public boolean finish(WizardDialogModel model): Beendet die Verarbeitung des Wizards
* public boolean cancel(WizardDialogModel model): Bricht die Verarbeitung ab

Folgende Methoden können genutzt und optional überschrieben werden:

* initializeDefaultPages(WizardDialogModel model): Initialisiert die Pages des Wizards mit dem Standardverhalten
* public boolean next(WizardDialogModel model): Rufe nächste Seite auf
* public boolean previous(WizardDialogModel model): Rufe vorherige Seite auf

[[drucklayout]]
==== Drucklayout

Wenn Daten aus der Applikation gedruckt werden sollen, muss der Inhalt für den Druck optimiert werden.
Die Definitionen des Druck-Layouts können über ein CSS Druck-Stylesheet geregelt werden.
Zum Beispiel sollten nicht benötigte Elemente ausgeblendet und Farben für den Druck optimiert werden.


:desc-image-seitendruck1: Seitendruck über Druck-Funktion des Browsers
[id="image-seitendruck1",reftext="{figure-caption} {counter:figures}"]
.{desc-image-seitendruck1}
image::image96.png[align="center", scaledwidth="96%"]

Für jede Seite besteht die Möglichkeit eine generische Druckansicht anzuzeigen.
Diese Druckansicht kann in einem eigenene View-State definiert werden.
Durch Aufruf des BasisControllers wird sie aktiviert oder deaktiviert.

Beispiel:

:desc-listing-druckAnsichtGenerisch: Generische Druckansicht anzeigen
[id="listing-druckAnsichtGenerisch",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-druckAnsichtGenerisch}
[source, xml]
----
<view-state id="auskunftAnzeigenDruckansichtViewState" model="auskunftAnzeigenModel">
    <on-entry>
       <evaluate expression="basisController.showPrintView()"/>
    </on-entry>
</view-state>
----

Über den Vererbungsmechanismus zwischen XHTML Seiten oder durch Angabe einer spezifischen View kann dadurch die komplette Seite in eine Druckansicht versetzt werden.
In der Druckansicht werden alle Elemente ohne JavaScript angezeigt und das Format entsprechend angepasst.
Mit der Druckfunktion des Browsers kann diese dann ausgedruckt werden.
Ruft man die Druckfunktion des Browsers direkt auf (ohne zuvor auf die Druckansicht geöffnet zu haben), so wird nur das angepasste CSS (print.css) verwendet.
Es erfolgen keine spezifischen Anpassungen von Elementen (z.B. alle Tabs anzeigen).

Das Tag `<isy:print-metainformation>` kann benutzt werden, um Metainformationen zum Druck anzuzeigen.
Der Inhalt dieses Tags wird nur ausgegeben, sofern die Druckansicht aktiviert ist.
Es enthält folgende Parameter:

* warning: Ein Text, welcher ausgegeben werden soll, falls ein Nutzer die Druckfunktion des Browsers nutzt, jedoch nicht die Druckansicht aktiviert hat.
Standard: leer.

[[drucken-bestimmter-inhaltesbereiche]]
===== Drucken bestimmter Inhaltsbereiche

Neben der allgemeinen Druck-Funktion des Browsers kann der Benutzer über explizite Drucken-Buttons bestimmte Bereiche ausdrucken.

Für eine spezifische Druckansicht von Komponenten kann über einen eigenen View-State die generische Druckansicht (siehe Drucklayout) verwendet werden.
Alternativ dazu können die Inhalte der Druckansicht auch selbst definiert und optimiert werden.
Zur Prüfung ob die Druckansicht aktiviert wurde dient das BasisModel.

===== Schnellnavigation 

*NOCH NICHT IMPLEMENTIERT*

Optional kann sich zur schnellen Navigation zwischen mehreren Ergebnissen ein Control zentriert in der Seiten-Toolbar befinden.
Es besteht aus Zurück- und Vor-Buttons, die durch die Anzeige der aktuellen Position und der Gesamtmenge getrennt sind.
Die Gesamtmenge entspricht der Anzahl der Objekte in der dahinterliegenden Übersichtsliste.

[[jsf-nutzung-isy-web]]
=== JSF Nutzung der isy-web

Der vorliegende Styleguide ist in einer Java Bibliothek (`isy-web`) umgesetzt.
Diese Bibliothek enthält notwendige Abhängigkeiten (Maven), Spring-Konfigurationen, CSS-Dateien, JSF-Komponenten (Composite Components) sowie zugehörige JSF-Templates (.xhtml). Die Bibliothek PLIS-Web setzt wiederum die Bibliothek PLIS-Style ein.
In der `isy-style` werden die CSS-, JavaScript- und Bilddateien des Styleguides abgelegt und für die Nutzung komprimiert und kompiliert.

In diesem Abschnitt werden die Grundlagen zur Nutzung der `isy-web` erläutert.
Details zur Architektur und weitere Vorgaben finden sich im Register Factory Detailkonzept Komponente Web GUI (TODO: Link ergänzen).

*Einbindung in Anwendung*

Bei Einsatz der `isy-web` werden viele Konfigurationen bereits vorgenommen.
Die Anwendung muss nur noch wenige Einstellungen vornehmen.
Nachfolgend werden diese Schritte erläutert.

==== JSP Konfiguration Maven

Die Maven Abhängigkeit für die `isy-web` lautet:

:desc-listing-jspMavenIsy: Einbindung der isy-web in Maven
[id="listing-jspMavenIsy",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-jspMavenIsy}
[source, xml]
----
<dependency>

<groupId>de.bund.bva.pliscommon</groupId>
   <artifactId>isy-web</artifactId>
   <version>x.y.z</version>

</dependency>
----

Die Bibliothek bringt alle notwendigen Abhängigkeiten mit (Spring, Spring-Webflow, JSF, etc.). Anpassungen an den Abhängigkeiten können direkt in der Abhängigkeitsdefinition der Anwendung durchgeführt werden.

==== JSP Konfiguration web.xml

Die web.xml der Anwendung muss entsprechend den Vorgaben konfiguriert werden (siehe Detailkonzept). Aus Sicht der Styleguide-Umsetzung ist vor allem die Konfiguration des ApplicationIntialisierungFilter wichtig.
Dieser Filter ist zuständig für die JavaScript Erkennung und die damit verbunden Konfiguration der globalen Einstellungen für die Session des Nutzers.
Beispiel:

:desc-listing-jspWebXmlKonfiguration: JSP web.xml Konfiguration
[id="listing-jspWebXmlKonfiguration",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-jspWebXmlKonfiguration}
[source, xml]
----
<filter> <filter-name>applicationInitialisierungFilter</filter-name>

<filter-class>de.bund.bva.isyfact.common.web.servlet.filter.ApplicationInitialisierungFilter</filter-class>

<!-- Optionaler Parameter: Der Parameter "urlsToSkip" dient zur Aufnahme von Url-Pfaden, relativ zum ApplicationContext-Pfad, die von der Filterung ausgenommen werden.
Mehrere Url-Pfade sind kommasepatiert anzugeben.
Es ist

pro Url ein fuehrendes "/" anzugeben. -->

<init-param> <param-name>urlsToSkip</param-name>
   <param-value>/app/resources</param-value>
</init-param>

<!-- Plicht-Parameter: Der Parameter "urlApplicationInitialisierung" enthaelt die Url zur Application-Initialisierungsseite.
Es ist ein fuehrendes "/" anzugeben. -->

<init-param>
   <param-name>urlApplicationInitialisierung</param-name>
   <param-value>/app/common/init/applicationInitialisierung.xhtml</param-value>
</init-param> </filter>
----

==== JSP Konfiguration Spring

Folgende Konfiguration müssen in die anwendungsspezifische Spring-Konfiguration übernommen werden:

* Für die GUI/Spring-Webflow: +
<import resource="classpath:resources/isy-web/spring/webflow.xml"/>
* Für die Widgets und Controller: +
<import resource="classpath:resources/isy-web/spring/controller.xml"/>
* Für Spring-Security: +
<import resource="classpath:resources/isy-web/spring/isy-sicherheit-web.xml"/>

Die eingebundenen Spring-Konfigurationen erwarten folgende Beans unter dem angegebenen Namen vorzufinden:

* Konfiguration ("konfiguration") Die Konfigurationsschnittstelle aus der isy-konfiguration.
* MessageSource ("messageSource") Die MessageSource (aus Spring Core) der Anwendung.
* AufrufKontextVerwalter ("aufrufKontextVerwalter") Den AufrufKontextVerwalter aus der isy-aufrufkontext zum Zugriff auf Nutzerinformationen.
* AufrufKontextFactory ("aufrufKontextFactory") Die AufrufKontextFactory aus der isy-aufrufkontext zum Erzeugen von AufrufKontext-Objekten.
* Sicherheit ("sicherheit") Die Sicherheit aus der isy-sicherheit.
* AusnahmeIdMapper ("ausnahmeIdMappper") Ein konkreter Ausnahme-ID-Mapper.
Zuständig für die Fehlerbehandlung in der GUI.


==== JSP Konfiguration Renderer

Derzeit muss noch folgende Konfiguration in die faces-config.xml der Anwendung aufgenommen werden:

:desc-listing-jspRenderer: JSP Renderer Konfiguration
[id="listing-jspRenderer",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-jspRenderer}
[source,xml]
----
<!-- Spezifische Renderer müssen hier erneut angegeben werden, um die existierenden Renderer aus der Tomahawk Bibliothek zu überschreiben -->
 <render-kit>
    <!-- Spezieller Renderer für t:radio Elemente, welcher kein Label rendert. -->
    <renderer> <component-family>org.apache.myfaces.Radio</component-family>
    <renderer-type>org.apache.myfaces.Radio</renderer-type>
    <renderer-class>de.bund.bva.isyfact.common.web.jsf.renderer.NoLabelHtmlRadioRenderer</renderer-class>
    </renderer>

<!-- Spezieller Renderer für Checkboxen, welcher kein Label rendert. -->
   <renderer>
      <component-family>org.apache.myfaces.Checkbox</component-family>
      <renderer-type>org.apache.myfaces.Checkbox</renderer-type>
      <renderer-class>de.bund.bva.isyfact.common.web.jsf.renderer.NoLabelHtmlCheckboxRenderer</renderer-class>
      </renderer>
  </render-kit>
----

==== Zugriff auf die isyFact Bibliothek

Zur Steuerung des Frameworks werden Controller und Models definiert, welche durch Einbindung der Spring-Konfiguration automatisch über Spring verfügbar sind, bzw.
per EL-Expressions in XHTML und Flows benutzt werden können (siehe Bean-Name in Klammern). Dies sind folgende:

* GlobalConfigurationController ("globalConfigurationController") mit GlobalConfigurationModel ("globalConfigurationModel" -ConversationScope) Enthält die globale Konfiguration der Nutzer-Session (z.B. Informationen über JavaScript Status)
* GlobalFlowController ("globalFlowController") mit GlobalFlowModel ("globalFlowModel" - FlowScope) Kontrolliert Zustände für einen konkreten Flow und bietet Zugriff auf querschnittsfunktionalität wie den MessageController und ValidationController (siehe unten)
* BasisController ("basisController") mit BasisModel ("basisModel" - FlowScope) Vereinigt die gemeinsamen Elemente und die Steuerung des Layouts für alle Seitentypen innerhalb der Anwendung.
Konfiguriert z.B. den Zugriff auf den Informationesbereich und auf die Seitentoolbar.
Stell Funktionen für die Druckansicht und für die Anzeige von modalen Dialogen zur Verfügung.
* ApplikationseiteController ("applikationseiteController") mit ApplikationseiteModel ("applikationseiteModel" - FlowScope) bzw.
DetailseiteController ("detailseiteController") mit DetailseiteModel ("detailseiteModel" - FlowScope) Konkrete Controller für die derzeit existierenden Seitentypen (siehe Applikationsseite und Applikation Detailseite).

Weiterhin existieren Controller für Teilbereiche:

* ErrorController ("errorController") mit ErrorModel ("errorModel" - FlowScope) Spezieller Controller und Model für die Darstellung der Fehlerseite.
* ValidationController ("validationController") mit ValidationModel ("validationModel" - FlashScope) Zuständig für die Verarbeitung von ValidationMessages (siehe auch Validierung).
* MessageController ("messageController") Verwaltet den Zugriff auf die FacesMessages im aktuellen FacesContext.
Stellt Methoden zur Ausgabe von Nachrichten bereit (siehe Vali dierung).
* LinksnavigationController ("linksnavigationController") und LinksnavigationModel ("linksnavigationModel" - FlowScope). Steuert die Linksnavigation.
Bietet Methoden zum manuellen Überschreiben der Linksnavigation (siehe Linksnavigation)
* QuicklinksController ("quicklinksController") und QuicklinksModel ("quicklinksModel - FlowScope). Steuert die Quicklinks.
Bietet Methoden zum Anlegen und Entfernen von Quicklinks (siehe Quicklinks).

==== Zugriff auf das Layout

Die Vorgabetemplates können über die JSF-Template Mechanismen eingebunden werden.
Das Framework stellt die Templates `/WEB-INF/gui/common/layout/applikation.xhtml` (Applikationseite) und `/WEB-INF/gui/common/layout/applikationDetailseite.xhtml` (Detailseite) zur Verfügung.
Diese erben wiederum von `/WEB-INF/gui/common/layout/basis.xhtml`, welches das grundlegende Layout vorgibt und alle notwendigen Skripte und Ressourcen einbindet.

Die Templates bieten folgende Schnittstellen über den ui:define/ui:insert Mechanismus von JSF an:

* inhaltsbereich: Der eigentliche Inhaltsbereich der Seite.

* headIncludes: Zum Einbinden von weiteren Ressourcen in den HTML Header.

* script: Zum Einbinden von seitenspezifischen JavaScript.

* modalDialogPlaceholder: Zum Einbinden von modalen Dialogen.

* printMetaInformation: Die Stelle um Meta-Informationen für Druckausgaben zu hinterlegen.

* form: Zusätzliche Form-Elemente können hier eingebunden werden.
Normalerweise stellt das Layout ein Form bereit.
Für spezifische Anpassungen (z.B. AJAX-Listpicker) müssen jedoch eigene Forms definiert werden.


Das CSS für den Styleguide wird automatisch geladen und eingebunden.
Zur anwendungsspezifischen Anpassung des CSS können folgende Dateien in der Anwendung verwendet werden:

* /css/custom-styles.css - Spezielle CSS Klassen für die Anwendung.

* /css/custom-print.css - Spezielle CSS Klassen für die Druckansicht der Anwendung.


==== Beispiel - Erzeugen einer neuen Maske

Im folgenden werden die Schritte aufgezeigt, welche durchgeführt werden müssen, um eine neue Maske mit der Nutzung des Styleguides anzulegen:

*Erzeugen eines Controllers und eines MaskenModels*

* Controller muss von AbstractGuiController erben.
* Controller muss in Spring als Bean konfiguriert werden.
* Model muss von AbstractMaskenModel erben.

==== Erzeugen der Flow-Definition für Spring-Webflow

Beispiel:

:desc-listing-jspFlowDefinitionWebFlow: JSP Flow Definition für Spring-Webflow
[id="listing-jspFlowDefinitionWebFlow",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-jspFlowDefinitionWebFlow}
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?> <flow xmlns="http://www.springframework.org/schema/webflow" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/webflow[http://www.springframework.org/schema/webflow http://www.springframework.org/schema/web]http://www.springframework.org/schema/webflow/spring-webflow-2.0.xsd[flow/spring-webflow-2.0.xsd]"

parent="applikationseiteParentFlow">

<secured attributes="..."/>

   <var name="beispielseiteMaskenModel"
       class="de.bund.bva....BeispielseiteMaskenModel"/>

   <on-start>
      <evaluate expression="beispielseiteMaskenController.initialisiereModel(beispielseiteMaskenModel)"/>
   </on-start>

   <view-state id="beispielseiteViewState" model="beispielseiteMaskenModel">
      ...
   </view-state>

   <end-state id="beendet" />

</flow>
----

Je nach Seitentyp muss entweder der detailseiteParentFlow oder der applikationseiteParentFlow als Parent-Flow angegeben werden.
Das Model wird als Variable definiert und damit im Flow erzeugt ("beispielseiteMaskenModel"). In der on-start Definition wird der Controller aufgerufen, um das Model zu initialisieren.
Dieser Schritt ist optional.

==== Erzeugen eines View-States

Beispiel:

:desc-listing-jspViewState: JSP ViewState
[id="listing-jspViewState",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-jspViewState}
[source,xml]
----
<!DOCTYPE composition PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd[http://www.w3.org/TR/xhtml1/DTD/xhtm]http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd[l1-transitional.dtd]">

<ui:composition xmlns="http://www.w3.org/1999/xhtml"
   xmlns:ui="http://java.sun.com/jsf/facelets" 
   xmlns:h="http://java.sun.com/jsf/html" 
   xmlns:f="http://java.sun.com/jsf/core" 
   xmlns:sf="http://www.springframework.org/tags/faces" 
   xmlns:isy="http://java.sun.com/jsf/composite/isyfact" 
   template="/WEB-INF/gui/common/layout/applikation.xhtml">

   <!-- Zusätzliches JS einbinden -->
   <ui:define name="script">
      <script type="text/javascript" src=".../beispielseite.js" />
   </ui:define>

   <!-- Form für AJAX-Seiteninhalt definieren -->
   <ui:define name="form">
     <h:form id="listpickerAjaxForm">
        <isy:formListpickerAjaxContent ... />
     </h:form>
    </ui:define>

   <!-- Metainformationen für die Druckausgabe -->
   <ui:define name="printMetaInformation">
      <ui:include src="...xhtml"/>
   </ui:define>

   <!-- Der Inhaltsbereich -->
   <ui:define name="inhaltsbereich">
      ...
   </ui:define>
</ui:composition>
----

Je nach Seitentyp muss entweder `/WEB-INF/gui/common/layout/applikationDetailseite.xhtml` oder
`/WEB-INF/gui/common/layout/applikation.xhtml` als Template angegeben werden.

==== Fehlerbehandlung

siehe auch System-Meldungen und Validierung.

Die Darstellung von technischen Ausnahmefehlern wird bereits automatisch von der Bibliothek übernommen.
Für Fehler beim Zugriff auf den Anwendungskern kann zusätzlich eine Fehlerbehandlung im Controller eingeführt werden (try/catch). So können checked und unchecked Exceptions abgefangen werden.
Der MessageController bietet hierzu Methoden (writeException, writeAndLogException) zum Loggen und Erzeugen von Fehlern/Warnungen im Nachrichtenbereich an.

Es gelten folgende Regelen:

* Fachliche Fehler (PlisBusinessException) werden als Warnmeldungen im Nachrichtenbereich der GUI angezeigt
* Andere Fehler (Laufzeitfehler, PlisTechnicalException, PlisTechnicalRuntimeException) werden mit einer technische Fehlermeldung im Nachrichtenbereich der GUI angezeigt.


[[konfiguration]]
= Konfiguration

Die allgemeinen Konfigurationen enthalten die anwendungsunabhängig benötigten Einstellungen um eine Web-GUI nach diesem
GUI-Konzept einzurichten.

[[uebersicht-konfigurationsdateien]]
== Übersicht Konfigurationsdateien

In diesem Kapitel soll kurz ein Überblick gegeben werden, an welchen Stellen und in welchen Dateien Konfigurationen vorgenommen werden.
Konkrete Beispiele finden sich in der <<Vorlageanwendung>> und den nachfolgenden Beispielen.
Im letzten Abschnitt wird aufgezeigt, welche Konfigurationen durchgeführt werden müssen, sofern die Bibliothek `isy-web` vollständig verwendet wird.

[[web.xml]]
=== web.xml

Die Datei `web.xml` ist der Web Deployment Deskriptor.
Dieser beschreibt die Teile der Web Applikation, welche für die Applikation die Schnittstellen nach außen darstellen.
Die `web.xml` enthält die notwendigen Konfigurationen, um die Teilsysteme, (JSF, Spring Web Flow, Security) zu aktivieren.
Die dazu notwendigen Einträge finden sich in den zugehörigen Abschnitten.

[[application.xml]]
=== application.xml

In der Datei `application.xml` sind alle zentralen Spring Konfigurationen enthalten.
Hier wird das Spring Basissystem mit seinen Konfigurationen festgelegt.
Für die Persistierung von Spring Beans kommt JPA mit Hibernate zum Einsatz (siehe <<Spring>>, <<JPA>> und <<DetailkonzeptKomponenteDatenzugriff>>).

[[webflow.xml]]
=== webflow.xml

Die Datei `webflow.xml` enthält die Spring Konfigurationen für die GUI-Frameworks (Webflow, JSF, Spring MVC).

[[isy-sicherheit-web.xml]]
=== isy-sicherheit-web.xml

Die Datei `isy-sicherheit-web.xml` beinhaltet die Konfiguration für die Spring Security Definition.
Hier wird konfiguriert, wie die Sicherheitskomponente an Spring Security angeschlossen wird.

[[faces-config.xml]]
=== faces-config.xml

In der Datei `faces-config.xml` sind die notwendigen Konfigurationen für Java Server Faces enthalten

[[basis-konfiguration-jsf]]
== Basis-Konfiguration JSF

Dieses Kapitel fasst alle notwendigen Basiskonfigurationen für die Verwendung von JSF zusammen.

[[verwendung-von-facelets-webflow.xml]]
=== Verwendung von Facelets (webflow.xml)

Für die Verwendung von Facelets ist es notwendig, in der Spring Konfiguration ein Mapping zwischen der Datei-Erweiterung
und den Facelets herzustellen.

:desc-listing-SnipConfigxml: Ausschnitt config.xml
[id="listing-SnipConfigxml",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-SnipConfigxml}
[source,xml]
----
<!-- Maps logical view names to Facelet templates (e.g. 'search' to '/WEB-INF/search.xhtml' -->
<bean id="faceletsViewResolver"
	class="org.springframework.web.servlet.view.UrlBasedViewResolver">
	<property name="viewClass"
		value="org.springframework.faces.mvc.JsfView" />
	<property name="prefix" value="/WEB-INF/" />
	<property name="suffix" value=".xhtml" />
</bean>
----

[[abschalten-der-ausgabe-von-kommentaren]]
=== Abschalten der Ausgabe von Kommentaren

Die Ausgabe von HTML-Kommentaren, die in der Flow-Definition und im View zur Dokumentation der Software eingebettet
wurden, wird abgeschaltet.

[[konfiguration-von-konvertern]]
=== Konfiguration von Konvertern

Um den gewünschten Konverter für die Verwendung bekannt zu machen, muss dieser in der `faces-config.xml` erfasst werden.

:desc-listing-SnipFacesConfigxml: Ausschnitt aus faces-config.xml
[id="listing-SnipFacesConfigxml",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-SnipFacesConfigxml}
[source,xml]
----
<converter>
	<converter-for-class>java.util.Date</converter-for-class>
	<converter-class>de.msg.terminfindung.gui.util.DateConverter</converter-class>
</converter>
----

[[aktivieren-von-partial-state-saving]]
=== Aktivieren von „Partial State Saving“

Das mit JSF 2.0 eingeführte Feature „Partial State Saving“ muss aktiviert bleiben.
Hintergrund ist, dass JSF 2.0 ansonsten im Zusammenhang mit der Replikation der Session die IDs für JSF-Komponenten
doppelt vergibt und es dadurch zu Fehlern in der Anwendung kommt.

[[erkennung-von-javascript-unterstuetzung]]
=== Erkennung von JavaScript Unterstützung

Je nach Browser und JavaScript Aktivierungsstatus muss die Anwendung Widgets verschieden darstellen.
Hierzu existiert ein Filter, welcher in die web.xml eingebunden wird.
Die Parameter müssen ggf.
angepasst werden.

:desc-listing-Snipwebxml2: Ausschnitt web.xml
[id="listing-Snipwebxml2",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-Snipwebxml2}
[source,xml]
----
<!-- Filter zur Initialisierung der Applikation (JavaScript De-/Aktiviert, ...). -->
	<filter>
		<filter-name>applicationInitialisierungFilter</filter-name>
		<filter-class>de.bund.bva.isyfact.common.web.servlet.filter.ApplicationInitialisierungFilter</filter-class>

		<!-- Optionaler Parameter: Der Parameter "urlsToSkip" dient zur Aufnahme von Url-Pfaden, relativ zum ApplicationContext-Pfad,
    		 die von der Filterung ausgenommen werden. Mehrere Url-Pfade sind kommasepatiert anzugeben. Es ist pro
			 Url ein fuehrendes
			 "/" anzugeben. -->
		<init-param>
			<param-name>urlsToSkip</param-name>
			<param-value>/app/resources</param-value>
		</init-param>

		<!-- Plicht-Parameter: Der Parameter "urlApplicationInitialisierung" enthaelt die Url zur Application-Initialisierungsseite.
			 Es ist ein fuehrendes "/" anzugeben. -->
		<init-param>
			<param-name>urlApplicationInitialisierung</param-name>
			<param-value>/app/common/init/applicationInitialisierung.xhtml</param-value>
		</init-param>
	</filter>
----

[[basis-konfiguration-web-flow]]
== Basis-Konfiguration Web Flow

Dieser Abschnitt beschreibt die Basiskonfiguration für die Verwendung von Spring Web Flow.

[[erweiterung-fuer-servlets-im-web.xml]]
=== Erweiterung für Servlets im web.xml

Damit die Funktionalitäten von Spring Web Flow aufgerufen werden, muss das SWF Dispatcher Servlet registriert werden,
welches die weitere Behandlung an den SWF Kern abgibt.

:desc-listing-Snipwebxml3: Ausschnitt web.xml bezüglich Servlets
[id="listing-Snipwebxml3",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-Snipwebxml3}
[source,xml]
----
<servlet>
	<servlet-name>dispatcher</servlet-name>
	<servlet-class>
		org.springframework.web.servlet.DispatcherServlet
	</servlet-class>
	<init-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/config.xml</param-value>
	</init-param>
	<load-on-startup>2</load-on-startup>
</servlet>

<servlet-mapping>
	<servlet-name>dispatcher</servlet-name>
	<url-pattern>/app/*</url-pattern>
</servlet-mapping>
----

[[konfiguration-der-navigation]]
== Konfiguration der Navigation

Nachfolgend werden die notwendigen Konfigurationen beschrieben, um die konkreten Dialog Flows zu definieren, und
wo die entsprechenden Anpassungen vorgenommen werden müssen.

[[jsf-flow-builder-service]]
=== JSF Flow Builder Service

Der JSF Flow Builder Service initialisiert aus der Dialog-Ablaufbeschreibung die konkreten Dialoge.
Zusätzlich kann hier noch der Expression Parser für die EL-Implementierung definiert werden.
Durch die Definition des EL-Parsers kann die konkrete EL-Implementierung festgelegt werden.
Standardmäßig sollte hier keine spezifische Konfiguration vorgenommen werden.

:desc-listing-SnipWebflow1xml: Ausschnitt aus Web Flow.xml
[id="listing-SnipWebflow1xml",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-SnipWebflow1xml}
[source,xml]
----
<!-- Configures the Spring Web Flow JSF integration -->
<faces:flow-builder-services id="facesFlowBuilderServices"
              expression-parser="expressionParser"/>
----

[[ablage-der-konfiguration]]
=== Ablage der Konfiguration

Innerhalb der Spring-Konfiguration wird für den Web Flow die „`flow-registry`“ konfiguriert.
Hier wird die Ablage der Konfigurations-Files definiert.

:desc-listing-SnipWebflow2xml: Ausschnitt aus Web Flow.xml
[id="listing-SnipWebflow2xml",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-SnipWebflow2xml}
[source,xml]
----
<!-- The registry of executable flow definitions -->
<webflow:flow-registry id="flowRegistry"
        flow-builder-services="facesFlowBuilderServices">
		<webflow:flow-location-pattern value="/WEB-INF/gui/flows/**/*Flow.xml" />
</webflow:flow-registry>
----

[[fehlerbehandlung-innerhalb-der-verarbeitung-der-gui]]
=== Fehlerbehandlung innerhalb der Verarbeitung der GUI

Für die Konfiguration der in Abschnitt <<behandlung-von-exceptions-innerhalb-der-verarbeitung-im-awk>>
erwähnten Fehlerbehandlung müssen die entsprechenden Schritte aus dem Kapitel durchgeführt werden.

[[konfiguration-logging]]
== Konfiguration Logging

Für das Logging kommt Log4j zum Einsatz.
Die notwendigen Konfigurationen und weitere Details sind in <<KonzeptLogging>> beschrieben.

Benötigte Libraries: `de.bund.bva.pliscommon.*isy-logging*`

Die Ablage der Log4J Konfiguration erfolgt in der Datei `web.xml`.

:desc-listing-SnipLogginConf1: Logging Konfiguration (Ausschnitt web.xml)
[id="listing-SnipLogginConf1",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-SnipLogginConf1}
[source,xml]
----
<!-- LOG4J Konfiguration
	Angabe des Speicherorts der log4j Konfiguration
	Wenn nicht angegeben, greift die Standardinitialisierung:
	Konfiguration im Classpath.
	Aufgrund des Deployoments liegt die Konfiguration aber unter
	/classes/config/log4j.properties
	Details siehe http://static.springframework.org/spring/docs
	/2.5.x/api/org/springframework/web/util/Log4jWebConfigurer.html
-->
<context-param>
	<param-name>log4jConfigLocation</param-name>
	<param-value>classpath:/config/log4j.properties</param-value>
</context-param>
----

Um Log-Einträge zu schreiben, bedient man sich im Sourcecode der bereitgestellten Methoden der Apache Log4J Implementierung.

[[konfiguration-security]]
== Konfiguration Security

[[setup-web.xml]]
=== Setup web.xml

Für den Einsatz von Spring Security ist ein Servlet Filter notwendig, in welchem die initialen
Abhandlungen der Berechtigungen erfolgen.

Hier wird die Ablage der Spring Security Konfiguration definiert.

:desc-listing-SnipWebxmlt5: Ausschnitt aus web.xml (bezüglich Security)
[id="listing-SnipWebxmlt5",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-SnipWebxmlt5}
[source,xml]
----
<!-- Spring Security filter, context parameter -->
<context-param>
	<param-name>contextConfigLocation</param-name>
	<param-value>classpath:resources/spring/applicationContext-security.xml
	</param-value>
</context-param>
----

Der Security Filter und die davon betroffenen URL-Patterns werden definiert.
Im Falle eines Einsatzes zur Absicherung der Dialogabläufe sollten alle Zugriffe abgesichert werden.

:desc-listing-SnipWebxmlt6: Ausschnitt aus web.xml (bezüglich Security-Filter)
[id="listing-SnipWebxmlt6",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-SnipWebxmlt6}
[source,xml]
----
<!-- Spring Security filter -->
<filter>
<filter-name>springSecurityFilterChain</filter-name>
<filter-class>
org.springframework.web.filter.DelegatingFilterProxy
</filter-class>
</filter>
<filter-mapping>
<filter-name>springSecurityFilterChain</filter-name>
<url-pattern>/*</url-pattern>
</filter-mapping>
----

Der Security Filter benötigt einen `ContextLoaderListener`, welcher wie folgt konfiguriert ist.

:desc-listing-SnipWebxmlt7: Ausschnitt aus web.xml (Contextloader)
[id="listing-SnipWebxmlt7",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-SnipWebxmlt7}
[source,xml]
----
<!-- Context Listener for the spring filter -->
<listener>
<listener-class>
org.springframework.web.context.ContextLoaderListener
</listener-class>
</listener>
----

[[spring-security-konfiguration]]
=== Spring Security Konfiguration

Die nachfolgende Spring Konfiguration erfolgt in der Datei `isy-sicherheit-web.xml`,
welche durch den Security Filter initial geladen wird.

Für die Konfiguration finden die nachfolgenden Namespaces Verwendung.

:desc-listing-SnipWebxmlSecu: Ausschnitt aus isy-sicherheit-web.xml (Namespace)
[id="listing-SnipWebxmlSecu",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-SnipWebxmlSecu}
[source,xml]
----
<beans:beans xmlns="http://www.springframework.org/schema/security"
xmlns:beans="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
http://www.springframework.org/schema/security
http://www.springframework.org/schema/security/spring-security-2.0.1.xsd">
----

Die Definition der HTTP-Konfiguration erfolgt in dem XML-Tag `<http>`.

:desc-listing-SnipApplContxtSec: Ausschnitt aus applicationContext-security.xml
[id="listing-SnipApplContxtSec",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-SnipApplContxtSec}
[source,xml]
----
<http auto-config="true">
	<form-login login-page="/login.jsp" />
</http>
----

Durch Spring Security wird die Verwendung von Annotationen bei der Berechtigungsprüfung ermöglicht.
Diese wird wie folgt aktiviert.

:desc-listing-SnipApplContextSec: Ausschnitt aus applicationContext-security.xml (Aktivierung)
[id="listing-SnipApplContextSec",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-SnipApplContextSec}
[source,xml]
----
<global-method-security secured-annotations="enabled" />
----

Die Konfiguration von Spring Security setzt die Definition eines User Services voraus.
Dieses kann nach aktuellem Stand nicht umgangen werden.
Daher wird ein Dummy Service definiert, welcher einen inaktiven Benutzer enthält.
Die Abfrage auf die realen Benutzer erfolgt im Authentication Provider, welcher im folgenden Kapitel beschrieben ist.

:desc-listing-SnipWebxmlSec: Ausschnitt aus isy-sicherheit-web.xml
[id="listing-SnipWebxmlSec",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-SnipWebxmlSec}
[source,xml]
----
<user-service>
	<user authorities="ROLE" name="name" password="password"
		  disabled="true" />
</user-service>
----

Für die Anbindung des Berechtigungsmanagers an Spring Security findet die Möglichkeit zur Erstellung
eines “Custom Authentication Providers” Anwendung.
In diesem Authentication Provider wird bei Bedarf überprüft ob der Nutzer die notwendigen Berechtigungen besitzt, bzw.
es wird für die weitere Verarbeitung in Spring Security der notwendige Kontext aufgebaut.

:desc-image-ClassConnSecKomp: Klassendiagramm Anbindung Sicherheitskomponente
[id="image-ClassConnSecKomp",reftext="{figure-caption} {counter:figures}"]
.{desc-image-ClassConnSecKomp}
image::ClassConnSecKomp.png[align="center"]

Das Sequenzdiagramm stellt den Zugriff des Authentication Providers auf die Sicherheitskomponente dar.
Hierbei werden die Rollen eines Benutzers über den Berechtigungsmanager gelesen und in einen Spring Security konformen
Token geschrieben.
Dieser Token findet dann bei der Autorisierung einzelner Benutzerinteraktion durch Spring Security Verwendung.

:desc-image-SecDiaAccessSec: Sequenzdiagramm Zugriff auf Sicherheitskomponente
[id="image-SecDiaAccessSec",reftext="{figure-caption} {counter:figures}"]
.{desc-image-SecDiaAccessSec}
image::SecDiaAccessSec.png[align="center"]

[[konfiguration-sicherheitskomponente]]
==== Konfiguration Sicherheitskomponente

Die Konfiguration der Sicherheitskomponente über eine properties-Datei ist im Konzept <<NutzungsvorgabenSicherheit>> beschrieben.

[[konfiguration-webflowauthenticationprovider]]
==== Konfiguration WebFlowAuthenticationProvider

Der `WebFlowAuthenticationProvider` erhält durch die Konfiguration die Instanz der Bean „`sicherheit`“ injected und wird
als „`custom-authentication-provider`“ Spring Security bekannt gemacht.

:desc-listing-SnipApcntxSec: Ausschnitt aus applicationContext-security.xml
[id="listing-SnipApcntxSec",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-SnipApcntxSec}
[source,xml]
----
<!-- ======================================================================
custom authentication provider setzen um Sicherheits Komponente für Rollen +
Ermittlung zu verwenden
====================================================================== -->
<beans:bean id="Web FlowAuthenticationProvider"
	class="de.bund.bva.pliscommon.plisweb.Web Flow.security.Web FlowAuthenticationProvider">
	<custom-authentication-provider />
	<beans:property name="sicherheit" ref="sicherheit" />
</beans:bean>
----

[[setup-spring-config-webflow.xml]]
=== Setup Spring Config (webflow.xml)

Hier muss ein Listener registriert werden, über welchen die Security Bedürfnisse geprüft werden.

:desc-listing-SnipWebFlowxx: Ausschnitt aus Web Flow.xml (bezüglich Security)
[id="listing-SnipWebFlowxx",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-SnipWebFlowxx}
[source,xml]
----
<bean name="flowExecutionSecurityListener"
      class="org.springframework.Web Flow.security.SecurityFlowExecutionListener">
</bean>

<bean name="flowExecutionListenerLoaderFactory"
	  class="org.springframework.Web Flow.config.FlowExecutionListenerLoaderFactoryBean">
	<property name="listeners">
		<map>
			<entry key-ref="flowExecutionSecurityListener"
				   value="cd-register"></entry>
			<entry key-ref="jpaFlowExecutionListener"
				   value="cd-register"></entry>
		</map>
	</property>
</bean>

<bean name="flowExecutionFactory"
	  class="org.springframework.Web Flow.engine.impl.FlowExecutionImplFactory">
	  <property name="executionKeyFactory"
		        ref="flowExecutionRepository"/>
	  <property name="executionListenerLoader"
				ref="flowExecutionListenerLoaderFactory"/>
</bean>
----

[[konfiguration-einer-anwendung-unter-nutzung-der-isy-web]]
== Konfiguration einer Anwendung unter Nutzung der `isy-web`

Bei Einsatz der Bibliothek `isy-web` werden viele Konfigurationen bereits vorgenommen.
Die Anwendung muss nur noch wenige Einstellungen vornehmen.
Hinweise zur Einbindung befinden sich auch im Styleguide <<Styleguide>>.

[[konfiguration-des-ressource-caching-mechanismus]]
== Konfiguration des Ressource Caching Mechanismus

Möchte man Webressourcen wie Bilder oder CSS-Dateien von Softwareversionen abhängig machen, muss das folgende gemacht werden:

[[jsf-resourcehandler-einrichten]]
=== JSF ResourceHandler einrichten

Die Ressourcenlieferung wird durch so genannte _ResourceHandler_ verkapselt.
Um also den Prozess anpassen zu können, muss man einen eigenen _ResourceHandler_ definieren und an die Web Applikation anbinden.
Da jedoch das GUI mittels JSF erstellt wird, muss es JSF-spezifisch umgesetzt werden.
Der folgende Code ist ein Beispiel so eines Handlers:

[source,java]
----
public class VersionierungResourceHandler extends ResourceHandlerWrapper {

	private ResourceHandler wrapped;
	private SystemVersionBean systemVersionBean;

	public VersionierungResourceHandler(ResourceHandler wrapped) {
		this.wrapped = wrapped;
		if (StatischerKontextInhaber.getApplicationContext() != null) {
			this.systemVersionBean =
				StatischerKontextInhaber.getApplicationContext().getBean(SystemVersionBean.class);
		}
	}

	@Override
	public Resource createResource(String resourceName) {
		return createResource(resourceName, null, null);
	}

	@Override
	public Resource createResource(String resourceName, String libraryName) {
		return createResource(resourceName, libraryName, null);
	}

	@Override
	public Resource createResource(String resourceName, String libraryName, String contentType) {
		final Resource resource = super.createResource(resourceName, libraryName, contentType);
		if (resource == null) {
			return null;
		}
		return new ResourceWrapper() {

			@Override
			public String getRequestPath() {
				String requestPath = super.getRequestPath();
				String version = "v=" + getSystemVersion();
				if (!requestPath.contains("?")) {
					return requestPath + "?" + version;
				}
				return requestPath + "&" + version;
			}

			@Override
			public Resource getWrapped() {
				return resource;
			}
		};
	}

	@Override
	public ResourceHandler getWrapped() {
		return this.wrapped;
	}

	private String getSystemVersion() {
		if (this.systemVersionBean == null && StatischerKontextInhaber.getApplicationContext() != null) {
			this.systemVersionBean = StatischerKontextInhaber.getApplicationContext().getBean(SystemVersionBean.class);
		}
		if (this.systemVersionBean == null) {
			this.systemVersionBean = new SystemVersionBean();
			this.systemVersionBean.setSystemVersion("DEV");
		}
		return this.systemVersionBean.getSystemVersion();
	}
}
----

In der Methode `getRequestPath()` kann man die Pfade der Ressourcen beliebig anpassen und zum Beispiel, wie oben gezeigt, eine Version an sie anhängen.

[[konfiguration-1]]
=== Konfiguration

Der _ResourceHandler_ muss noch mittels Konfiguration an die Web Applikation angebunden werden.
Dies macht man in `faces-config.xml` auf die folgende Weise:

[source,xml]
----
<application>
	<resource-handler>pfad.VersionierungResourceHandler<resource-handler/>
</application>
----

[[jsf-tags-benutzen]]
=== JSF Tags benutzen

Es gibt noch eine letzte Bedingung die man erfüllen muss, damit der JSF _ResourceHandler_ die Ressourcen überhaupt behandelt.
Es müssen JSF Tags benutzt werden:

* JavaScript: `<h:outputScript>` anstatt `<script>`
* CSS: `<h:outputStylesheet>` anstatt `<link>`

Dank ihnen werden die jeweiligen Ressourcen für unseren _ResourceHandler_ sichtbar und werden von ihn nun verwaltet.

[[optionale-anzeige-der-versionsnummer-im-webseitentitel]]
== Optionale Anzeige der Versionsnummer im Webseitentitel

Es besteht die Möglichkeit, die Versionsnummer einer Anwendung im Webseitentitel anzuzeigen.
Hierzu muss der Parameter _gui.versionsanzeige.seitentitel.aktiv_ in einer Konfigurationsdatei der Anwendung hinterlegt sein und auf _true_ gesetzt werden.
Ist der Parameter nicht hinterlegt, so ist die Anzeige standardmäßig nicht aktiviert und es ist nichts zu tun (Abwärtskompatibilität).

Zusätzlich muss der Parameter `system.version` in einer Konfigurationsdatei hinterlegt sein.
Dieser Parameter enthält die aktuelle Version der Anwendung.
Es empfiehlt sich, die Versionsnummer beim Build automatisch zu setzen.
Außerdem kann im Parameter `system.name` der Name der Anwendung hinterlegt werden.
Dies ist jedoch nicht zwingend nötig.
Die Anzeige der Versionsnummer funktioniert auch ohne Angabe des Anwendungsnamens.
Dieser entfällt dann einfach.
In <<listing-AnzeigeVersionNameImTitel>> finden sich eine beispielhafte Konfiguration und in <<image-DispNameVersTitle>> wird das eigentliche Feature gezeigt.

:desc-listing-AnzeigeVersionNameImTitel: Konfiguration der Anzeige von Name und Version im Seitentitel
[id="listing-AnzeigeVersionNameImTitel",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-AnzeigeVersionNameImTitel}
[source,ruby]
----
# Ob die Versionsnummer im Seitentitel angezeigt werden soll.
# Mögliche Werte true oder false. Standardwert ist false.
gui.versionsanzeige.seitentitel.aktiv=true

# Die Systemversion wird in richtigen Anwendungen automatisch
# über Maven aktualisiert. Hat hier einfach einen festen
# Wert, da sie nur für Beispiele verwendet wird.
system.version=1.2.3

# Der Systemname
system.name=Terminfindung
----

:desc-image-DispNameVersTitle: Anzeige von Name und Version im Seitentitel
[id="image-DispNameVersTitle",reftext="{figure-caption} {counter:figures}"]
.{desc-image-DispNameVersTitle}
image::DispNameVersTitle.png[align="center",width=60%,pdfwidth=60%]

[[session-behandlung]]
= Session Behandlung

Die nachfolgenden Kapitel beschäftigen sich mit der Behandlung der Session Informationen, welche in Spring Web Flow anfallen.
Hierunter fallen alle Daten, die für die Dialogabläufe benötigt werden:

* Komponentenbaum der Dialogansicht, dieser beinhaltet die Dialogelemente und die Information über die Bindung an die Backing Beans.
* Den Flow Container, in welchem die Backing Beans während dem Dialogfluss vorgehalten werden.
* Die Conversation, welche eine Benutzer Interaktion beinhaltet, bündelt die beiden vorangegangenen Angaben.

Standardmäßig wird diese Information in der HTTP Session abgelegt und wieder hergestellt.
Nach IsyFact-Zielarchitektur erfolgt diese Speicherung in der Datenbank.
Diese Funktionalität übernimmt der Tomcat.
Eine Anpassung der Anwendung ist nicht erforderlich.

[[vergabe-von-cookies-session-ids]]
== Vergabe von Cookies / Session IDs

Für die Identifikation abgelegter Conversations von Spring Web Flow wird auf die Daten im Cookie zurückgegriffen.
Der Cookie wird einmalig definiert und ist durch die Session ID vorgegeben.

Die Vergabe der Session IDs erfolgt über die Standardmechanismen innerhalb des Tomcat.
Bei der Anforderung einer neuen Session innerhalb der Applikation, was für den Benutzer nicht sichtbar ist, wird die neue ID vergeben und an die Session gebunden.
Die Nutzung von Cookies ist zwingend erforderlich, ansonsten können die Webanwendungen nicht genutzt werden.

[[session-zugriff]]
== Session Zugriff

Für die Arbeit mit Spring Web Flow ist es notwendig, die in der Session notwendigen Daten der Conversation für
jeden Schritt bereitzustellen und nach jedem Schritt abzulegen.
Hierfür werden die Daten in der Datenbank persistiert.
Dies erfolgt über einen eigenen Session-Manager im Tomcat (siehe <<TomcatNutzungskonzept>>). Es handelt sich dabei
um eine Erweiterung der IsyFact.
Wenn diese Erweiterung nicht eingesetzt wird, muss entweder die Session-Persistierung auf andere Weise durchgeführt
werden, oder es muss sichergestellt werden, dass die Requests eines Benutzers immer auf die gleiche
Tomcat-Instanz gehen (Sticky Sessions). Die Session-Daten müssen dabei möglichst klein gehalten werden, um
die Performance der Anwendung nicht zu verschlechtern.
Die Größe der Session wird maßgeblich durch die „im Webflow“ gespeicherten Model-Daten bestimmt.
Daher muss darauf geachtet werden nur unbedingt notwendige Daten im Model zu halten.

[[migration-zu-tomcat-session-persistierung-plis-web-2.3.x]]
== Migration zu Tomcat-Session-Persistierung (plis-web-2.3.x)

Vor der plis-web-Version 2.3.0 erfolgte die Persistierung der Session-Daten in der Datenbank auf Ebene der
Anwendung durch eine Erweiterung von Spring-Web-Flow.
Dafür mussten Klassen eingebunden werden, die von plis-web zur Verfügung gestellt wurden.
In plis-web-Version 2.3.0 sind diese Klassen als deprecated markiert, weil die Session-Persistierung nun
transparent vom Tomcat durchgeführt wird (siehe <<TomcatNutzungskonzept>>). Solange die Tomcat Erweiterung zur
automatischen Persistierung der Session nicht eingesetzt wird, müssen die als deprecated markierten Klassen
weiter verwendet werden.
Die folgenden Schritte fassen die Unterschiede und Migrationsschritte von einer früheren plis-web-Version
zu plis-web-2.3.0:

.  Die Anwendung muss innerhalb eines Tomcat laufen, der -gemäß dem Konzept <<TomcatNutzungskonzept>> betrieben wird.
Der JDBC-Sessionmanager muss wie dort beschrieben aktiviert und konfiguriert werden.
.  Die Definition der Bean `DbBasedConversationContainer­StoreService` muss von dem Spring-Kontext der Anwendung entfernt werden.
.  Die Bean, welche für das Aufräumen der Datenbank-Sessions zuständig ist (`jobExecutorStoreClean`) und die zugehörige Timer-Factory muss von dem Spring-Kontext der Anwendung entfernt werden, weil das Aufräumen der Datenbank-Sessions auch vom Tomcat verwaltet wird.
.  Die Bean DbBasedBindingConversationManager muss im Spring-Kontext der Anwendung mit der Spring-Web-Flow-Klasse
`SessionBindingConversationManager` ersetzt werden.
.  Die Datenbank-Tabelle für die Sessions (`WEBFLOW­CONVERSATIONCONTAINER`) muss entfernt werden.
Sie wird mit einer neuen Datenbank-Tabelle ersetzt, die im <<TomcatNutzungskonzept>> beschrieben ist.

[[transaktionssteuerung]]
== Transaktionssteuerung

Alle Zugriffe auf die Datenbank müssen in einer Transaktion verpackt werden.
Die Transaktionssteuerung wird dabei vom AWK-Wrapper durch Annotation (`@Transactional`) der Klasse übernommen.

Aus Sicht der GUI-Schicht bedeutet dies, dass jeder Aufruf des AWKs unmittelbar eine Änderung der Daten zufolge hat.
Um eine parallele Aktualisierung eines Datensatzes zu verhindern, können die entsprechenden Versionsnummern der
JPA-Entiäten verwendet werden, indem diese mit in die GUI-Entitäten geladen werden.

[[checkliste-zur-qs]]
= Checkliste zur QS

Die Checkliste für die QS stellt Prüfpunkte zur Verfügung, anhand derer wichtige Kriterien zur Umsetzung der
Oberfläche überprüft werden können.

[[id-vergabe-jsf]]
== ID Vergabe JSF

Für automatisierte Tests ist es notwendig, für Eingabefelder und Controls eine konkrete und in der Seite eindeutige ID zu vergeben.

Wird für eine Komponente keine ID vorgegeben, so erzeugt JSF die IDs dynamisch.
Ein Test über ein GUI-Testwerkzeug wird somit erschwert.

[[verwendung-der-http-session]]
== Verwendung der HTTP-Session

Aufgrund der Vorgabe eines zustandslosen Servers ist nicht sichergestellt, dass der Anwendung beim nächsten
Zugriff auf einen Server die HTTP-Session zur Verfügung steht.
Daher ist es notwendig die Masken und Abläufe so zu entwerfen, das hierauf verzichtet werden kann.

[[nutzung-model-beans]]
== Nutzung Model Beans

Jeder Flow muss eine (oder mehrere) Model Bean hinterlegt haben, in welcher die Daten für die Maske vorgehalten werden.

[[transaktionsbehandlung-1]]
== Transaktionsbehandlung

Bei mehrschrittigen Datenerfassungen muss die Behandlung der Transaktion mit einem besonderen Augenmerk behandelt werden.

[[einhaltung-styleguide]]
== Einhaltung Styleguide

Die Applikation muss auf die Vorgaben des Styleguides überprüft werden.
Der Styleguide befindet sich unter <<Styleguide>>.

[[flow-konfiguration]]
== Flow Konfiguration

Für jede Maske sollte der Flow in einer eigenständigen Konfiguration hinterlegt sein, damit kann jede Maske separat
ausgetauscht und gewartet werden.
Jeder Flow sollte entsprechend dem Layout von dem vorgegebenen Parent-Flow erben.

[[optimierung-jsf-design]]
== Optimierung JSF Design

Aufgrund der automatischen Ablage eines JSF Komponenten-Baumes in der Conversation und damit in der Datenbank,
ist es notwendig sich über die Größe des Komponenten-Baumes Gedanken zu machen.

Begrenzung der real verwendeten Komponenten auf die Ein und Ausgabe Elemente.
Statische Texte bevorzugt nur im HTML verwenden.

[[optimierung-snapshots]]
== Optimierung Snapshots

Für die Benutzung des Back-Buttons ist es notwendig, die Anzahl der Snapshots eines Dialogflusses zu erhöhen.
Dieses sollte in Abhängigkeit der Anforderungen an die konkrete Anwendung erfolgen.

[[festlegung-der-texte-fuer-die-titel]]
== Festlegung der Texte für die Titel

Es sollte ein Standard-Titel und Präfix für die Anwendung angelegt werden.

[[festlegung-der-hilfeseiten]]
== Festlegung der Hilfeseiten

Für alle Masken sollte eine zugehörige Hilfe verfügbar sein, und der Aufruf auf die Seite muss überprüft werden.

[[generische-fehlermeldung]]
== Fehlerbehandlung

Alle Exceptions werden an einer definierten Stelle behandelt.
Für technische Fehler werden keine Details, sondern eine generische Fehlermeldung angezeigt.

[[flow-und-masken-security]]
== Flow und Masken Security

Der Zugriff auf Masken und Dialogelemente muss anhand der Systemspezifikation überprüft werden.

[[regeln-bei-der-javascript-programmierung]]
== Regeln bei der JavaScript-Programmierung

Die unter <<interaktive-elemente-mit-jquery>> und <<vermeidung-von-sicherheitsluecken-bei-aktiviertem-javascript>>
beschriebenen Regeln müssen überprüft werden.

[[regeln-der-sicheren-softwareentwicklung]]
== Regeln der sicheren Softwareentwicklung

Bei der Entwicklung von Web-Anwendungen müssen in besonderem Maße Sicherheitsaspekte berücksichtigt werden.
Die entsprechenden Regeln sind in beschrieben.
